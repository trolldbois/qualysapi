#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Dec  6 12:13:05 2018 by generateDS.py version 2.30.8.
# Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'webapp.py')
#
# Command line arguments:
#   webapp.xsd
#
# Command line:
#   C:\Users\ljaqueme\DOCUME~1\02-THR~1\05-INT~1\10-IR-~1\V_IR-T~2\Scripts\generateDS -o "webapp.py" webapp.xsd
#
# Current working directory (os.getcwd()):
#   gen
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ResponseCode(object):
    AUTH_CREDENTIALS_NEEDED='AUTH_CREDENTIALS_NEEDED'
    CANNOT_BE_NULL='CANNOT_BE_NULL'
    INVALID_XML='INVALID_XML'
    INVALID_CREDENTIALS='INVALID_CREDENTIALS'
    INVALID_API_VERSION='INVALID_API_VERSION'
    INVALID_PARAM='INVALID_PARAM'
    INVALID_URL='INVALID_URL'
    INVALID_REQUEST='INVALID_REQUEST'
    NOT_FOUND='NOT_FOUND'
    OTHER_ERROR='OTHER_ERROR'
    OPERATION_NOT_SUPPORTED='OPERATION_NOT_SUPPORTED'
    EVALUATION_EXPIRED='EVALUATION_EXPIRED'
    JMS_SERVER_DOWN='JMS_SERVER_DOWN'
    RMI_SERVER_DOWN='RMI_SERVER_DOWN'
    SUCCESS='SUCCESS'
    STILL_PROCESSING='STILL_PROCESSING'
    UNAUTHORIZED='UNAUTHORIZED'
    UNAUTHORIZED_DESTINATION_APPS='UNAUTHORIZED_DESTINATION_APPS'
    UNIDENTIFIED_PRODUCER='UNIDENTIFIED_PRODUCER'
    UNKNOWN_OBJECT='UNKNOWN_OBJECT'


class WeekDay(object):
    MONDAY='MONDAY'
    TUESDAY='TUESDAY'
    WEDNESDAY='WEDNESDAY'
    THURSDAY='THURSDAY'
    FRIDAY='FRIDAY'
    SATURDAY='SATURDAY'
    SUNDAY='SUNDAY'


class dayOrderType(object):
    FIRST='FIRST'
    SECOND='SECOND'
    THIRD='THIRD'
    FOURTH='FOURTH'
    LAST='LAST'


class occurrenceTypeType(object):
    ONCE='ONCE'
    HOURLY='HOURLY'
    DAILY='DAILY'
    WEEKLY='WEEKLY'
    MONTHLY='MONTHLY'


class scopeType(object):
    ALL='ALL'
    LIMIT='LIMIT'
    SUBDOMAIN='SUBDOMAIN'
    DOMAINS='DOMAINS'


class typeType(object):
    EXTERNAL='EXTERNAL'
    INTERNAL='INTERNAL'


class useRobotsType(object):
    IGNORE='IGNORE'
    ADD_PATHS='ADD_PATHS'
    BLACKLIST='BLACKLIST'


class ServiceRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filters=None, preferences=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.filters = filters
        self.preferences = preferences
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequest.subclass:
            return ServiceRequest.subclass(*args_, **kwargs_)
        else:
            return ServiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filters(self):
        return self.filters
    def set_filters(self, filters):
        self.filters = filters
    def get_preferences(self):
        return self.preferences
    def set_preferences(self, preferences):
        self.preferences = preferences
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def hasContent_(self):
        if (
            self.filters is not None or
            self.preferences is not None or
            self.data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.filters is not None:
            self.filters.export(outfile, level, namespaceprefix_, name_='filters', pretty_print=pretty_print)
        if self.preferences is not None:
            self.preferences.export(outfile, level, namespaceprefix_, name_='preferences', pretty_print=pretty_print)
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'filters':
            obj_ = ServiceRequestFilters.factory(parent_object_=self)
            obj_.build(child_)
            self.filters = obj_
            obj_.original_tagname_ = 'filters'
        elif nodeName_ == 'preferences':
            obj_ = ServiceRequestPreferences.factory(parent_object_=self)
            obj_.build(child_)
            self.preferences = obj_
            obj_.original_tagname_ = 'preferences'
        elif nodeName_ == 'data':
            obj_ = ServiceRequestData.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
# end class ServiceRequest


class ServiceRequestFilters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Criteria=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Criteria is None:
            self.Criteria = []
        else:
            self.Criteria = Criteria
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestFilters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestFilters.subclass:
            return ServiceRequestFilters.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestFilters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Criteria(self):
        return self.Criteria
    def set_Criteria(self, Criteria):
        self.Criteria = Criteria
    def add_Criteria(self, value):
        self.Criteria.append(value)
    def add_Criteria(self, value):
        self.Criteria.append(value)
    def insert_Criteria_at(self, index, value):
        self.Criteria.insert(index, value)
    def replace_Criteria_at(self, index, value):
        self.Criteria[index] = value
    def hasContent_(self):
        if (
            self.Criteria
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestFilters', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestFilters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestFilters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestFilters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestFilters'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestFilters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Criteria_ in self.Criteria:
            Criteria_.export(outfile, level, namespaceprefix_, name_='Criteria', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Criteria':
            obj_ = Criteria.factory(parent_object_=self)
            obj_.build(child_)
            self.Criteria.append(obj_)
            obj_.original_tagname_ = 'Criteria'
# end class ServiceRequestFilters


class Criteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, name=None, operator=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.field = _cast(None, field)
        self.name = _cast(None, name)
        self.operator = _cast(None, operator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Criteria)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Criteria.subclass:
            return Criteria.subclass(*args_, **kwargs_)
        else:
            return Criteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Criteria', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Criteria')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Criteria')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Criteria', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Criteria'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.name), input_name='name')), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Criteria', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Criteria


class ServiceRequestPreferences(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, startFromId=None, startFromOffset=None, limitResults=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.startFromId = startFromId
        self.startFromOffset = startFromOffset
        self.limitResults = limitResults
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestPreferences)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestPreferences.subclass:
            return ServiceRequestPreferences.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestPreferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startFromId(self):
        return self.startFromId
    def set_startFromId(self, startFromId):
        self.startFromId = startFromId
    def get_startFromOffset(self):
        return self.startFromOffset
    def set_startFromOffset(self, startFromOffset):
        self.startFromOffset = startFromOffset
    def get_limitResults(self):
        return self.limitResults
    def set_limitResults(self, limitResults):
        self.limitResults = limitResults
    def hasContent_(self):
        if (
            self.startFromId is not None or
            self.startFromOffset is not None or
            self.limitResults is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestPreferences', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestPreferences')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestPreferences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestPreferences', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestPreferences'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestPreferences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startFromId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartFromId>%s</%sstartFromId>%s' % (namespaceprefix_ , self.gds_format_integer(self.startFromId, input_name='startFromId'), namespaceprefix_ , eol_))
        if self.startFromOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartFromOffset>%s</%sstartFromOffset>%s' % (namespaceprefix_ , self.gds_format_integer(self.startFromOffset, input_name='startFromOffset'), namespaceprefix_ , eol_))
        if self.limitResults is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitResults>%s</%slimitResults>%s' % (namespaceprefix_ , self.gds_format_integer(self.limitResults, input_name='limitResults'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startFromId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startFromId')
            self.startFromId = ival_
        elif nodeName_ == 'startFromOffset' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startFromOffset')
            self.startFromOffset = ival_
        elif nodeName_ == 'limitResults' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limitResults')
            self.limitResults = ival_
# end class ServiceRequestPreferences


class ServiceRequestData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebApp=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.WebApp = WebApp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestData.subclass:
            return ServiceRequestData.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebApp(self):
        return self.WebApp
    def set_WebApp(self, WebApp):
        self.WebApp = WebApp
    def hasContent_(self):
        if (
            self.WebApp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestData'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebApp is not None:
            self.WebApp.export(outfile, level, namespaceprefix_, name_='WebApp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebApp':
            obj_ = WebApp.factory(parent_object_=self)
            obj_.build(child_)
            self.WebApp = obj_
            obj_.original_tagname_ = 'WebApp'
# end class ServiceRequestData


class ServiceResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, responseCode=None, responseErrorDetails=None, count=None, hasMoreRecords=None, lastId=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.responseCode = responseCode
        self.validate_ResponseCode(self.responseCode)
        self.responseErrorDetails = responseErrorDetails
        self.count = count
        self.hasMoreRecords = hasMoreRecords
        self.lastId = lastId
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceResponse.subclass:
            return ServiceResponse.subclass(*args_, **kwargs_)
        else:
            return ServiceResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_responseCode(self):
        return self.responseCode
    def set_responseCode(self, responseCode):
        self.responseCode = responseCode
    def get_responseErrorDetails(self):
        return self.responseErrorDetails
    def set_responseErrorDetails(self, responseErrorDetails):
        self.responseErrorDetails = responseErrorDetails
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_hasMoreRecords(self):
        return self.hasMoreRecords
    def set_hasMoreRecords(self, hasMoreRecords):
        self.hasMoreRecords = hasMoreRecords
    def get_lastId(self):
        return self.lastId
    def set_lastId(self, lastId):
        self.lastId = lastId
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def validate_ResponseCode(self, value):
        # Validate type ResponseCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUTH_CREDENTIALS_NEEDED', 'CANNOT_BE_NULL', 'INVALID_XML', 'INVALID_CREDENTIALS', 'INVALID_API_VERSION', 'INVALID_PARAM', 'INVALID_URL', 'INVALID_REQUEST', 'NOT_FOUND', 'OTHER_ERROR', 'OPERATION_NOT_SUPPORTED', 'EVALUATION_EXPIRED', 'JMS_SERVER_DOWN', 'RMI_SERVER_DOWN', 'SUCCESS', 'STILL_PROCESSING', 'UNAUTHORIZED', 'UNAUTHORIZED_DESTINATION_APPS', 'UNIDENTIFIED_PRODUCER', 'UNKNOWN_OBJECT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ResponseCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.responseCode is not None or
            self.responseErrorDetails is not None or
            self.count is not None or
            self.hasMoreRecords is not None or
            self.lastId is not None or
            self.data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.responseCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresponseCode>%s</%sresponseCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.responseCode), input_name='responseCode')), namespaceprefix_ , eol_))
        if self.responseErrorDetails is not None:
            self.responseErrorDetails.export(outfile, level, namespaceprefix_, name_='responseErrorDetails', pretty_print=pretty_print)
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.hasMoreRecords is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shasMoreRecords>%s</%shasMoreRecords>%s' % (namespaceprefix_ , self.gds_format_boolean(self.hasMoreRecords, input_name='hasMoreRecords'), namespaceprefix_ , eol_))
        if self.lastId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastId>%s</%slastId>%s' % (namespaceprefix_ , self.gds_format_integer(self.lastId, input_name='lastId'), namespaceprefix_ , eol_))
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'responseCode':
            responseCode_ = child_.text
            responseCode_ = self.gds_validate_string(responseCode_, node, 'responseCode')
            self.responseCode = responseCode_
            # validate type ResponseCode
            self.validate_ResponseCode(self.responseCode)
        elif nodeName_ == 'responseErrorDetails':
            obj_ = ResponseErrorObject.factory(parent_object_=self)
            obj_.build(child_)
            self.responseErrorDetails = obj_
            obj_.original_tagname_ = 'responseErrorDetails'
        elif nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'hasMoreRecords':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasMoreRecords')
            self.hasMoreRecords = ival_
        elif nodeName_ == 'lastId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastId')
            self.lastId = ival_
        elif nodeName_ == 'data':
            obj_ = ServiceResponseData.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
# end class ServiceResponse


class ResponseErrorObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, errorMessage=None, errorResolution=None, internalErrorCodeId=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.errorMessage = errorMessage
        self.errorResolution = errorResolution
        self.internalErrorCodeId = internalErrorCodeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseErrorObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseErrorObject.subclass:
            return ResponseErrorObject.subclass(*args_, **kwargs_)
        else:
            return ResponseErrorObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_errorResolution(self):
        return self.errorResolution
    def set_errorResolution(self, errorResolution):
        self.errorResolution = errorResolution
    def get_internalErrorCodeId(self):
        return self.internalErrorCodeId
    def set_internalErrorCodeId(self, internalErrorCodeId):
        self.internalErrorCodeId = internalErrorCodeId
    def hasContent_(self):
        if (
            self.errorMessage is not None or
            self.errorResolution is not None or
            self.internalErrorCodeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseErrorObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseErrorObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseErrorObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseErrorObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseErrorObject'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseErrorObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.errorResolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorResolution>%s</%serrorResolution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorResolution), input_name='errorResolution')), namespaceprefix_ , eol_))
        if self.internalErrorCodeId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinternalErrorCodeId>%s</%sinternalErrorCodeId>%s' % (namespaceprefix_ , self.gds_format_integer(self.internalErrorCodeId, input_name='internalErrorCodeId'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'errorMessage':
            errorMessage_ = child_.text
            errorMessage_ = self.gds_validate_string(errorMessage_, node, 'errorMessage')
            self.errorMessage = errorMessage_
        elif nodeName_ == 'errorResolution':
            errorResolution_ = child_.text
            errorResolution_ = self.gds_validate_string(errorResolution_, node, 'errorResolution')
            self.errorResolution = errorResolution_
        elif nodeName_ == 'internalErrorCodeId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'internalErrorCodeId')
            self.internalErrorCodeId = ival_
# end class ResponseErrorObject


class ServiceResponseData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebApp=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebApp is None:
            self.WebApp = []
        else:
            self.WebApp = WebApp
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceResponseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceResponseData.subclass:
            return ServiceResponseData.subclass(*args_, **kwargs_)
        else:
            return ServiceResponseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebApp(self):
        return self.WebApp
    def set_WebApp(self, WebApp):
        self.WebApp = WebApp
    def add_WebApp(self, value):
        self.WebApp.append(value)
    def add_WebApp(self, value):
        self.WebApp.append(value)
    def insert_WebApp_at(self, index, value):
        self.WebApp.insert(index, value)
    def replace_WebApp_at(self, index, value):
        self.WebApp[index] = value
    def hasContent_(self):
        if (
            self.WebApp
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponseData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceResponseData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceResponseData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceResponseData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceResponseData'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponseData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebApp_ in self.WebApp:
            WebApp_.export(outfile, level, namespaceprefix_, name_='WebApp', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebApp':
            obj_ = WebApp.factory(parent_object_=self)
            obj_.build(child_)
            self.WebApp.append(obj_)
            obj_.original_tagname_ = 'WebApp'
# end class ServiceResponseData


class WebApp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, url=None, os=None, owner=None, scope='ALL', subDomain=None, domains=None, uris=None, attributes=None, defaultProfile=None, defaultScanner=None, defaultScannerTags=None, scannerLocked=False, progressiveScanning=None, redundancyLinks=None, maxRedundancyLinks=None, urlBlacklist=None, urlWhitelist=None, postDataBlacklist=None, logoutRegexList=None, authRecords=None, dnsOverrides=None, useRobots='IGNORE', useSitemap=False, headers=None, malwareMonitoring=None, malwareNotification=None, malwareTaskId=None, malwareScheduling=None, tags=None, comments=None, isScheduled=None, lastScan=None, createdBy=None, createdDate=None, updatedBy=None, updatedDate=None, screenshot=None, proxy=None, config=None, crawlingScripts=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
        self.url = url
        self.os = os
        self.owner = owner
        self.scope = scope
        self.validate_scopeType(self.scope)
        self.subDomain = subDomain
        self.domains = domains
        self.uris = uris
        self.attributes = attributes
        self.defaultProfile = defaultProfile
        self.defaultScanner = defaultScanner
        self.defaultScannerTags = defaultScannerTags
        self.scannerLocked = scannerLocked
        self.progressiveScanning = progressiveScanning
        self.redundancyLinks = redundancyLinks
        self.maxRedundancyLinks = maxRedundancyLinks
        self.urlBlacklist = urlBlacklist
        self.urlWhitelist = urlWhitelist
        self.postDataBlacklist = postDataBlacklist
        self.logoutRegexList = logoutRegexList
        self.authRecords = authRecords
        self.dnsOverrides = dnsOverrides
        self.useRobots = useRobots
        self.validate_useRobotsType(self.useRobots)
        self.useSitemap = useSitemap
        self.headers = headers
        self.malwareMonitoring = malwareMonitoring
        self.malwareNotification = malwareNotification
        self.malwareTaskId = malwareTaskId
        self.malwareScheduling = malwareScheduling
        self.tags = tags
        self.comments = comments
        self.isScheduled = isScheduled
        self.lastScan = lastScan
        self.createdBy = createdBy
        if isinstance(createdDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createdDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createdDate
        self.createdDate = initvalue_
        self.updatedBy = updatedBy
        if isinstance(updatedDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updatedDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updatedDate
        self.updatedDate = initvalue_
        self.screenshot = screenshot
        self.proxy = proxy
        self.config = config
        self.crawlingScripts = crawlingScripts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebApp)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebApp.subclass:
            return WebApp.subclass(*args_, **kwargs_)
        else:
            return WebApp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def get_os(self):
        return self.os
    def set_os(self, os):
        self.os = os
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    def get_scope(self):
        return self.scope
    def set_scope(self, scope):
        self.scope = scope
    def get_subDomain(self):
        return self.subDomain
    def set_subDomain(self, subDomain):
        self.subDomain = subDomain
    def get_domains(self):
        return self.domains
    def set_domains(self, domains):
        self.domains = domains
    def get_uris(self):
        return self.uris
    def set_uris(self, uris):
        self.uris = uris
    def get_attributes(self):
        return self.attributes
    def set_attributes(self, attributes):
        self.attributes = attributes
    def get_defaultProfile(self):
        return self.defaultProfile
    def set_defaultProfile(self, defaultProfile):
        self.defaultProfile = defaultProfile
    def get_defaultScanner(self):
        return self.defaultScanner
    def set_defaultScanner(self, defaultScanner):
        self.defaultScanner = defaultScanner
    def get_defaultScannerTags(self):
        return self.defaultScannerTags
    def set_defaultScannerTags(self, defaultScannerTags):
        self.defaultScannerTags = defaultScannerTags
    def get_scannerLocked(self):
        return self.scannerLocked
    def set_scannerLocked(self, scannerLocked):
        self.scannerLocked = scannerLocked
    def get_progressiveScanning(self):
        return self.progressiveScanning
    def set_progressiveScanning(self, progressiveScanning):
        self.progressiveScanning = progressiveScanning
    def get_redundancyLinks(self):
        return self.redundancyLinks
    def set_redundancyLinks(self, redundancyLinks):
        self.redundancyLinks = redundancyLinks
    def get_maxRedundancyLinks(self):
        return self.maxRedundancyLinks
    def set_maxRedundancyLinks(self, maxRedundancyLinks):
        self.maxRedundancyLinks = maxRedundancyLinks
    def get_urlBlacklist(self):
        return self.urlBlacklist
    def set_urlBlacklist(self, urlBlacklist):
        self.urlBlacklist = urlBlacklist
    def get_urlWhitelist(self):
        return self.urlWhitelist
    def set_urlWhitelist(self, urlWhitelist):
        self.urlWhitelist = urlWhitelist
    def get_postDataBlacklist(self):
        return self.postDataBlacklist
    def set_postDataBlacklist(self, postDataBlacklist):
        self.postDataBlacklist = postDataBlacklist
    def get_logoutRegexList(self):
        return self.logoutRegexList
    def set_logoutRegexList(self, logoutRegexList):
        self.logoutRegexList = logoutRegexList
    def get_authRecords(self):
        return self.authRecords
    def set_authRecords(self, authRecords):
        self.authRecords = authRecords
    def get_dnsOverrides(self):
        return self.dnsOverrides
    def set_dnsOverrides(self, dnsOverrides):
        self.dnsOverrides = dnsOverrides
    def get_useRobots(self):
        return self.useRobots
    def set_useRobots(self, useRobots):
        self.useRobots = useRobots
    def get_useSitemap(self):
        return self.useSitemap
    def set_useSitemap(self, useSitemap):
        self.useSitemap = useSitemap
    def get_headers(self):
        return self.headers
    def set_headers(self, headers):
        self.headers = headers
    def get_malwareMonitoring(self):
        return self.malwareMonitoring
    def set_malwareMonitoring(self, malwareMonitoring):
        self.malwareMonitoring = malwareMonitoring
    def get_malwareNotification(self):
        return self.malwareNotification
    def set_malwareNotification(self, malwareNotification):
        self.malwareNotification = malwareNotification
    def get_malwareTaskId(self):
        return self.malwareTaskId
    def set_malwareTaskId(self, malwareTaskId):
        self.malwareTaskId = malwareTaskId
    def get_malwareScheduling(self):
        return self.malwareScheduling
    def set_malwareScheduling(self, malwareScheduling):
        self.malwareScheduling = malwareScheduling
    def get_tags(self):
        return self.tags
    def set_tags(self, tags):
        self.tags = tags
    def get_comments(self):
        return self.comments
    def set_comments(self, comments):
        self.comments = comments
    def get_isScheduled(self):
        return self.isScheduled
    def set_isScheduled(self, isScheduled):
        self.isScheduled = isScheduled
    def get_lastScan(self):
        return self.lastScan
    def set_lastScan(self, lastScan):
        self.lastScan = lastScan
    def get_createdBy(self):
        return self.createdBy
    def set_createdBy(self, createdBy):
        self.createdBy = createdBy
    def get_createdDate(self):
        return self.createdDate
    def set_createdDate(self, createdDate):
        self.createdDate = createdDate
    def get_updatedBy(self):
        return self.updatedBy
    def set_updatedBy(self, updatedBy):
        self.updatedBy = updatedBy
    def get_updatedDate(self):
        return self.updatedDate
    def set_updatedDate(self, updatedDate):
        self.updatedDate = updatedDate
    def get_screenshot(self):
        return self.screenshot
    def set_screenshot(self, screenshot):
        self.screenshot = screenshot
    def get_proxy(self):
        return self.proxy
    def set_proxy(self, proxy):
        self.proxy = proxy
    def get_config(self):
        return self.config
    def set_config(self, config):
        self.config = config
    def get_crawlingScripts(self):
        return self.crawlingScripts
    def set_crawlingScripts(self, crawlingScripts):
        self.crawlingScripts = crawlingScripts
    def validate_scopeType(self, value):
        # Validate type scopeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ALL', 'LIMIT', 'SUBDOMAIN', 'DOMAINS']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on scopeType' % {"value" : value.encode("utf-8")} )
    def validate_useRobotsType(self, value):
        # Validate type useRobotsType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['IGNORE', 'ADD_PATHS', 'BLACKLIST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on useRobotsType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.url is not None or
            self.os is not None or
            self.owner is not None or
            self.scope != "ALL" or
            self.subDomain is not None or
            self.domains is not None or
            self.uris is not None or
            self.attributes is not None or
            self.defaultProfile is not None or
            self.defaultScanner is not None or
            self.defaultScannerTags is not None or
            self.scannerLocked or
            self.progressiveScanning is not None or
            self.redundancyLinks is not None or
            self.maxRedundancyLinks is not None or
            self.urlBlacklist is not None or
            self.urlWhitelist is not None or
            self.postDataBlacklist is not None or
            self.logoutRegexList is not None or
            self.authRecords is not None or
            self.dnsOverrides is not None or
            self.useRobots != "IGNORE" or
            self.useSitemap or
            self.headers is not None or
            self.malwareMonitoring is not None or
            self.malwareNotification is not None or
            self.malwareTaskId is not None or
            self.malwareScheduling is not None or
            self.tags is not None or
            self.comments is not None or
            self.isScheduled is not None or
            self.lastScan is not None or
            self.createdBy is not None or
            self.createdDate is not None or
            self.updatedBy is not None or
            self.updatedDate is not None or
            self.screenshot is not None or
            self.proxy is not None or
            self.config is not None or
            self.crawlingScripts is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebApp', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebApp')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebApp')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebApp', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebApp'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebApp', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.url is not None:
            self.url.export(outfile, level, namespaceprefix_, name_='url', pretty_print=pretty_print)
        if self.os is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sos>%s</%sos>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.os), input_name='os')), namespaceprefix_ , eol_))
        if self.owner is not None:
            self.owner.export(outfile, level, namespaceprefix_, name_='owner', pretty_print=pretty_print)
        if self.scope != "ALL":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscope>%s</%sscope>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.scope), input_name='scope')), namespaceprefix_ , eol_))
        if self.subDomain is not None:
            self.subDomain.export(outfile, level, namespaceprefix_, name_='subDomain', pretty_print=pretty_print)
        if self.domains is not None:
            self.domains.export(outfile, level, namespaceprefix_, name_='domains', pretty_print=pretty_print)
        if self.uris is not None:
            self.uris.export(outfile, level, namespaceprefix_, name_='uris', pretty_print=pretty_print)
        if self.attributes is not None:
            self.attributes.export(outfile, level, namespaceprefix_, name_='attributes', pretty_print=pretty_print)
        if self.defaultProfile is not None:
            self.defaultProfile.export(outfile, level, namespaceprefix_, name_='defaultProfile', pretty_print=pretty_print)
        if self.defaultScanner is not None:
            self.defaultScanner.export(outfile, level, namespaceprefix_, name_='defaultScanner', pretty_print=pretty_print)
        if self.defaultScannerTags is not None:
            self.defaultScannerTags.export(outfile, level, namespaceprefix_, name_='defaultScannerTags', pretty_print=pretty_print)
        if self.scannerLocked:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sscannerLocked>%s</%sscannerLocked>%s' % (namespaceprefix_ , self.gds_format_boolean(self.scannerLocked, input_name='scannerLocked'), namespaceprefix_ , eol_))
        if self.progressiveScanning is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprogressiveScanning>%s</%sprogressiveScanning>%s' % (namespaceprefix_ , self.gds_format_boolean(self.progressiveScanning, input_name='progressiveScanning'), namespaceprefix_ , eol_))
        if self.redundancyLinks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sredundancyLinks>%s</%sredundancyLinks>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.redundancyLinks), input_name='redundancyLinks')), namespaceprefix_ , eol_))
        if self.maxRedundancyLinks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxRedundancyLinks>%s</%smaxRedundancyLinks>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.maxRedundancyLinks), input_name='maxRedundancyLinks')), namespaceprefix_ , eol_))
        if self.urlBlacklist is not None:
            self.urlBlacklist.export(outfile, level, namespaceprefix_, name_='urlBlacklist', pretty_print=pretty_print)
        if self.urlWhitelist is not None:
            self.urlWhitelist.export(outfile, level, namespaceprefix_, name_='urlWhitelist', pretty_print=pretty_print)
        if self.postDataBlacklist is not None:
            self.postDataBlacklist.export(outfile, level, namespaceprefix_, name_='postDataBlacklist', pretty_print=pretty_print)
        if self.logoutRegexList is not None:
            self.logoutRegexList.export(outfile, level, namespaceprefix_, name_='logoutRegexList', pretty_print=pretty_print)
        if self.authRecords is not None:
            self.authRecords.export(outfile, level, namespaceprefix_, name_='authRecords', pretty_print=pretty_print)
        if self.dnsOverrides is not None:
            self.dnsOverrides.export(outfile, level, namespaceprefix_, name_='dnsOverrides', pretty_print=pretty_print)
        if self.useRobots != "IGNORE":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseRobots>%s</%suseRobots>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.useRobots), input_name='useRobots')), namespaceprefix_ , eol_))
        if self.useSitemap:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suseSitemap>%s</%suseSitemap>%s' % (namespaceprefix_ , self.gds_format_boolean(self.useSitemap, input_name='useSitemap'), namespaceprefix_ , eol_))
        if self.headers is not None:
            self.headers.export(outfile, level, namespaceprefix_, name_='headers', pretty_print=pretty_print)
        if self.malwareMonitoring is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smalwareMonitoring>%s</%smalwareMonitoring>%s' % (namespaceprefix_ , self.gds_format_boolean(self.malwareMonitoring, input_name='malwareMonitoring'), namespaceprefix_ , eol_))
        if self.malwareNotification is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smalwareNotification>%s</%smalwareNotification>%s' % (namespaceprefix_ , self.gds_format_boolean(self.malwareNotification, input_name='malwareNotification'), namespaceprefix_ , eol_))
        if self.malwareTaskId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smalwareTaskId>%s</%smalwareTaskId>%s' % (namespaceprefix_ , self.gds_format_integer(self.malwareTaskId, input_name='malwareTaskId'), namespaceprefix_ , eol_))
        if self.malwareScheduling is not None:
            self.malwareScheduling.export(outfile, level, namespaceprefix_, name_='malwareScheduling', pretty_print=pretty_print)
        if self.tags is not None:
            self.tags.export(outfile, level, namespaceprefix_, name_='tags', pretty_print=pretty_print)
        if self.comments is not None:
            self.comments.export(outfile, level, namespaceprefix_, name_='comments', pretty_print=pretty_print)
        if self.isScheduled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisScheduled>%s</%sisScheduled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isScheduled, input_name='isScheduled'), namespaceprefix_ , eol_))
        if self.lastScan is not None:
            self.lastScan.export(outfile, level, namespaceprefix_, name_='lastScan', pretty_print=pretty_print)
        if self.createdBy is not None:
            self.createdBy.export(outfile, level, namespaceprefix_, name_='createdBy', pretty_print=pretty_print)
        if self.createdDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.createdDate, input_name='createdDate'), namespaceprefix_ , eol_))
        if self.updatedBy is not None:
            self.updatedBy.export(outfile, level, namespaceprefix_, name_='updatedBy', pretty_print=pretty_print)
        if self.updatedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedDate>%s</%supdatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.updatedDate, input_name='updatedDate'), namespaceprefix_ , eol_))
        if self.screenshot is not None:
            self.screenshot.export(outfile, level, namespaceprefix_, name_='screenshot', pretty_print=pretty_print)
        if self.proxy is not None:
            self.proxy.export(outfile, level, namespaceprefix_, name_='proxy', pretty_print=pretty_print)
        if self.config is not None:
            self.config.export(outfile, level, namespaceprefix_, name_='config', pretty_print=pretty_print)
        if self.crawlingScripts is not None:
            self.crawlingScripts.export(outfile, level, namespaceprefix_, name_='crawlingScripts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
        elif nodeName_ == 'os':
            os_ = child_.text
            os_ = self.gds_validate_string(os_, node, 'os')
            self.os = os_
        elif nodeName_ == 'owner':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.owner = obj_
            obj_.original_tagname_ = 'owner'
        elif nodeName_ == 'scope':
            scope_ = child_.text
            scope_ = self.gds_validate_string(scope_, node, 'scope')
            self.scope = scope_
            # validate type scopeType
            self.validate_scopeType(self.scope)
        elif nodeName_ == 'subDomain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.subDomain = obj_
            obj_.original_tagname_ = 'subDomain'
        elif nodeName_ == 'domains':
            obj_ = DomainList.factory(parent_object_=self)
            obj_.build(child_)
            self.domains = obj_
            obj_.original_tagname_ = 'domains'
        elif nodeName_ == 'uris':
            obj_ = UrlList.factory(parent_object_=self)
            obj_.build(child_)
            self.uris = obj_
            obj_.original_tagname_ = 'uris'
        elif nodeName_ == 'attributes':
            obj_ = AttributeList.factory(parent_object_=self)
            obj_.build(child_)
            self.attributes = obj_
            obj_.original_tagname_ = 'attributes'
        elif nodeName_ == 'defaultProfile':
            obj_ = WasScanOptionProfile.factory(parent_object_=self)
            obj_.build(child_)
            self.defaultProfile = obj_
            obj_.original_tagname_ = 'defaultProfile'
        elif nodeName_ == 'defaultScanner':
            obj_ = ScannerAppliance.factory(parent_object_=self)
            obj_.build(child_)
            self.defaultScanner = obj_
            obj_.original_tagname_ = 'defaultScanner'
        elif nodeName_ == 'defaultScannerTags':
            obj_ = TagList.factory(parent_object_=self)
            obj_.build(child_)
            self.defaultScannerTags = obj_
            obj_.original_tagname_ = 'defaultScannerTags'
        elif nodeName_ == 'scannerLocked':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'scannerLocked')
            self.scannerLocked = ival_
        elif nodeName_ == 'progressiveScanning':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'progressiveScanning')
            self.progressiveScanning = ival_
        elif nodeName_ == 'redundancyLinks':
            redundancyLinks_ = child_.text
            redundancyLinks_ = self.gds_validate_string(redundancyLinks_, node, 'redundancyLinks')
            self.redundancyLinks = redundancyLinks_
        elif nodeName_ == 'maxRedundancyLinks':
            maxRedundancyLinks_ = child_.text
            maxRedundancyLinks_ = self.gds_validate_string(maxRedundancyLinks_, node, 'maxRedundancyLinks')
            self.maxRedundancyLinks = maxRedundancyLinks_
        elif nodeName_ == 'urlBlacklist':
            obj_ = UrlEntryList.factory(parent_object_=self)
            obj_.build(child_)
            self.urlBlacklist = obj_
            obj_.original_tagname_ = 'urlBlacklist'
        elif nodeName_ == 'urlWhitelist':
            obj_ = UrlEntryList.factory(parent_object_=self)
            obj_.build(child_)
            self.urlWhitelist = obj_
            obj_.original_tagname_ = 'urlWhitelist'
        elif nodeName_ == 'postDataBlacklist':
            obj_ = UrlEntryList.factory(parent_object_=self)
            obj_.build(child_)
            self.postDataBlacklist = obj_
            obj_.original_tagname_ = 'postDataBlacklist'
        elif nodeName_ == 'logoutRegexList':
            obj_ = UrlEntryList.factory(parent_object_=self)
            obj_.build(child_)
            self.logoutRegexList = obj_
            obj_.original_tagname_ = 'logoutRegexList'
        elif nodeName_ == 'authRecords':
            obj_ = WebAppAuthRecordList.factory(parent_object_=self)
            obj_.build(child_)
            self.authRecords = obj_
            obj_.original_tagname_ = 'authRecords'
        elif nodeName_ == 'dnsOverrides':
            obj_ = DnsOverrideList.factory(parent_object_=self)
            obj_.build(child_)
            self.dnsOverrides = obj_
            obj_.original_tagname_ = 'dnsOverrides'
        elif nodeName_ == 'useRobots':
            useRobots_ = child_.text
            useRobots_ = self.gds_validate_string(useRobots_, node, 'useRobots')
            self.useRobots = useRobots_
            # validate type useRobotsType
            self.validate_useRobotsType(self.useRobots)
        elif nodeName_ == 'useSitemap':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'useSitemap')
            self.useSitemap = ival_
        elif nodeName_ == 'headers':
            obj_ = WebAppHeaderList.factory(parent_object_=self)
            obj_.build(child_)
            self.headers = obj_
            obj_.original_tagname_ = 'headers'
        elif nodeName_ == 'malwareMonitoring':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'malwareMonitoring')
            self.malwareMonitoring = ival_
        elif nodeName_ == 'malwareNotification':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'malwareNotification')
            self.malwareNotification = ival_
        elif nodeName_ == 'malwareTaskId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'malwareTaskId')
            self.malwareTaskId = ival_
        elif nodeName_ == 'malwareScheduling':
            obj_ = SchedulePlanification.factory(parent_object_=self)
            obj_.build(child_)
            self.malwareScheduling = obj_
            obj_.original_tagname_ = 'malwareScheduling'
        elif nodeName_ == 'tags':
            obj_ = TagList.factory(parent_object_=self)
            obj_.build(child_)
            self.tags = obj_
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'comments':
            obj_ = CommentList.factory(parent_object_=self)
            obj_.build(child_)
            self.comments = obj_
            obj_.original_tagname_ = 'comments'
        elif nodeName_ == 'isScheduled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isScheduled')
            self.isScheduled = ival_
        elif nodeName_ == 'lastScan':
            obj_ = WasScan.factory(parent_object_=self)
            obj_.build(child_)
            self.lastScan = obj_
            obj_.original_tagname_ = 'lastScan'
        elif nodeName_ == 'createdBy':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.createdBy = obj_
            obj_.original_tagname_ = 'createdBy'
        elif nodeName_ == 'createdDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createdDate = dval_
        elif nodeName_ == 'updatedBy':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.updatedBy = obj_
            obj_.original_tagname_ = 'updatedBy'
        elif nodeName_ == 'updatedDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updatedDate = dval_
        elif nodeName_ == 'screenshot':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.screenshot = obj_
            obj_.original_tagname_ = 'screenshot'
        elif nodeName_ == 'proxy':
            obj_ = HttpProxy.factory(parent_object_=self)
            obj_.build(child_)
            self.proxy = obj_
            obj_.original_tagname_ = 'proxy'
        elif nodeName_ == 'config':
            obj_ = WebAppConfig.factory(parent_object_=self)
            obj_.build(child_)
            self.config = obj_
            obj_.original_tagname_ = 'config'
        elif nodeName_ == 'crawlingScripts':
            obj_ = CrawlingScriptList.factory(parent_object_=self)
            obj_.build(child_)
            self.crawlingScripts = obj_
            obj_.original_tagname_ = 'crawlingScripts'
# end class WebApp


class Cdata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cdata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cdata.subclass:
            return Cdata.subclass(*args_, **kwargs_)
        else:
            return Cdata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cdata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cdata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cdata')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cdata', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cdata'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cdata', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Cdata


class UrlList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UrlList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UrlList.subclass:
            return UrlList.subclass(*args_, **kwargs_)
        else:
            return UrlList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UrlList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UrlList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UrlList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UrlList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class UrlList


class Url(Cdata):
    subclass = None
    superclass = Cdata
    def __init__(self, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Url, self).__init__(valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Url)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Url.subclass:
            return Url.subclass(*args_, **kwargs_)
        else:
            return Url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Url, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Url', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Url')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Url')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Url', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Url'):
        super(Url, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Url')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Url', fromsubclass_=False, pretty_print=True):
        super(Url, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Url, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Url


class User(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, username=None, firstName=None, lastName=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.username = username
        self.firstName = firstName
        self.lastName = lastName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, User)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if User.subclass:
            return User.subclass(*args_, **kwargs_)
        else:
            return User(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    def get_firstName(self):
        return self.firstName
    def set_firstName(self, firstName):
        self.firstName = firstName
    def get_lastName(self):
        return self.lastName
    def set_lastName(self, lastName):
        self.lastName = lastName
    def hasContent_(self):
        if (
            self.id is not None or
            self.username is not None or
            self.firstName is not None or
            self.lastName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='User', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('User')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='User')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='User', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='User'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='User', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.firstName is not None:
            self.firstName.export(outfile, level, namespaceprefix_, name_='firstName', pretty_print=pretty_print)
        if self.lastName is not None:
            self.lastName.export(outfile, level, namespaceprefix_, name_='lastName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'firstName':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.firstName = obj_
            obj_.original_tagname_ = 'firstName'
        elif nodeName_ == 'lastName':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.lastName = obj_
            obj_.original_tagname_ = 'lastName'
# end class User


class HttpProxy(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
        self.url = url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HttpProxy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HttpProxy.subclass:
            return HttpProxy.subclass(*args_, **kwargs_)
        else:
            return HttpProxy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_url(self):
        return self.url
    def set_url(self, url):
        self.url = url
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.url is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HttpProxy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HttpProxy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HttpProxy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HttpProxy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HttpProxy'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HttpProxy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.url is not None:
            self.url.export(outfile, level, namespaceprefix_, name_='url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.url = obj_
            obj_.original_tagname_ = 'url'
# end class HttpProxy


class WebAppConfig(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cancelScansAfterNHours=None, cancelScansAt=None, defaultAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cancelScansAfterNHours = cancelScansAfterNHours
        self.cancelScansAt = cancelScansAt
        self.defaultAuthRecord = defaultAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppConfig)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppConfig.subclass:
            return WebAppConfig.subclass(*args_, **kwargs_)
        else:
            return WebAppConfig(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cancelScansAfterNHours(self):
        return self.cancelScansAfterNHours
    def set_cancelScansAfterNHours(self, cancelScansAfterNHours):
        self.cancelScansAfterNHours = cancelScansAfterNHours
    def get_cancelScansAt(self):
        return self.cancelScansAt
    def set_cancelScansAt(self, cancelScansAt):
        self.cancelScansAt = cancelScansAt
    def get_defaultAuthRecord(self):
        return self.defaultAuthRecord
    def set_defaultAuthRecord(self, defaultAuthRecord):
        self.defaultAuthRecord = defaultAuthRecord
    def hasContent_(self):
        if (
            self.cancelScansAfterNHours is not None or
            self.cancelScansAt is not None or
            self.defaultAuthRecord is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppConfig', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppConfig')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppConfig')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppConfig', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppConfig'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppConfig', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cancelScansAfterNHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelScansAfterNHours>%s</%scancelScansAfterNHours>%s' % (namespaceprefix_ , self.gds_format_integer(self.cancelScansAfterNHours, input_name='cancelScansAfterNHours'), namespaceprefix_ , eol_))
        if self.cancelScansAt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelScansAt>%s</%scancelScansAt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cancelScansAt), input_name='cancelScansAt')), namespaceprefix_ , eol_))
        if self.defaultAuthRecord is not None:
            self.defaultAuthRecord.export(outfile, level, namespaceprefix_, name_='defaultAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cancelScansAfterNHours' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cancelScansAfterNHours')
            self.cancelScansAfterNHours = ival_
        elif nodeName_ == 'cancelScansAt':
            cancelScansAt_ = child_.text
            cancelScansAt_ = self.gds_validate_string(cancelScansAt_, node, 'cancelScansAt')
            self.cancelScansAt = cancelScansAt_
        elif nodeName_ == 'defaultAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.defaultAuthRecord = obj_
            obj_.original_tagname_ = 'defaultAuthRecord'
# end class WebAppConfig


class DomainList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DomainList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DomainList.subclass:
            return DomainList.subclass(*args_, **kwargs_)
        else:
            return DomainList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DomainList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DomainList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DomainList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DomainList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DomainList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DomainList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType1.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType2.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType3.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType4.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType5.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class DomainList


class Domain(Cdata):
    subclass = None
    superclass = Cdata
    def __init__(self, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(Domain, self).__init__(valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Domain)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Domain.subclass:
            return Domain.subclass(*args_, **kwargs_)
        else:
            return Domain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(Domain, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Domain', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Domain')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Domain')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Domain', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Domain'):
        super(Domain, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Domain')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Domain', fromsubclass_=False, pretty_print=True):
        super(Domain, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Domain, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Domain


class AttributeList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AttributeList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AttributeList.subclass:
            return AttributeList.subclass(*args_, **kwargs_)
        else:
            return AttributeList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AttributeList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AttributeList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AttributeList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AttributeList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AttributeList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType6.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType7.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType8.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType9.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType10.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class AttributeList


class Attribute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Attribute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Attribute.subclass:
            return Attribute.subclass(*args_, **kwargs_)
        else:
            return Attribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.name is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Attribute', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Attribute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Attribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Attribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Attribute'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Attribute', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'value':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class Attribute


class WasScanOptionProfile(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WasScanOptionProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WasScanOptionProfile.subclass:
            return WasScanOptionProfile.subclass(*args_, **kwargs_)
        else:
            return WasScanOptionProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WasScanOptionProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WasScanOptionProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WasScanOptionProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WasScanOptionProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WasScanOptionProfile'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WasScanOptionProfile', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class WasScanOptionProfile


class ScannerAppliance(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, friendlyName=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
        self.validate_typeType(self.type_)
        self.friendlyName = friendlyName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ScannerAppliance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ScannerAppliance.subclass:
            return ScannerAppliance.subclass(*args_, **kwargs_)
        else:
            return ScannerAppliance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_friendlyName(self):
        return self.friendlyName
    def set_friendlyName(self, friendlyName):
        self.friendlyName = friendlyName
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['EXTERNAL', 'INTERNAL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.friendlyName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScannerAppliance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ScannerAppliance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ScannerAppliance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ScannerAppliance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ScannerAppliance'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ScannerAppliance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.friendlyName is not None:
            self.friendlyName.export(outfile, level, namespaceprefix_, name_='friendlyName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type typeType
            self.validate_typeType(self.type_)
        elif nodeName_ == 'friendlyName':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.friendlyName = obj_
            obj_.original_tagname_ = 'friendlyName'
# end class ScannerAppliance


class UrlEntryList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UrlEntryList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UrlEntryList.subclass:
            return UrlEntryList.subclass(*args_, **kwargs_)
        else:
            return UrlEntryList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlEntryList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UrlEntryList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UrlEntryList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UrlEntryList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UrlEntryList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlEntryList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType11.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType12.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType13.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType14.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType15.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class UrlEntryList


class UrlEntry(Cdata):
    subclass = None
    superclass = Cdata
    def __init__(self, regex=False, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(UrlEntry, self).__init__(valueOf_,  **kwargs_)
        self.regex = _cast(bool, regex)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UrlEntry)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UrlEntry.subclass:
            return UrlEntry.subclass(*args_, **kwargs_)
        else:
            return UrlEntry(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_regex(self):
        return self.regex
    def set_regex(self, regex):
        self.regex = regex
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(UrlEntry, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlEntry', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UrlEntry')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UrlEntry')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UrlEntry', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UrlEntry'):
        super(UrlEntry, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UrlEntry')
        if self.regex and 'regex' not in already_processed:
            already_processed.add('regex')
            outfile.write(' regex="%s"' % self.gds_format_boolean(self.regex, input_name='regex'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UrlEntry', fromsubclass_=False, pretty_print=True):
        super(UrlEntry, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('regex', node)
        if value is not None and 'regex' not in already_processed:
            already_processed.add('regex')
            if value in ('true', '1'):
                self.regex = True
            elif value in ('false', '0'):
                self.regex = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(UrlEntry, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UrlEntry


class WebAppAuthRecordList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthRecordList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthRecordList.subclass:
            return WebAppAuthRecordList.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthRecordList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecordList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthRecordList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthRecordList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthRecordList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthRecordList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecordList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType16.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType17.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType18.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType19.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
# end class WebAppAuthRecordList


class WebAppAuthRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthRecord.subclass:
            return WebAppAuthRecord.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecord', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthRecord'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class WebAppAuthRecord


class DnsOverrideList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DnsOverrideList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DnsOverrideList.subclass:
            return DnsOverrideList.subclass(*args_, **kwargs_)
        else:
            return DnsOverrideList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DnsOverrideList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DnsOverrideList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DnsOverrideList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DnsOverrideList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DnsOverrideList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DnsOverrideList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType20.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType21.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType22.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType23.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
# end class DnsOverrideList


class DnsOverride(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DnsOverride)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DnsOverride.subclass:
            return DnsOverride.subclass(*args_, **kwargs_)
        else:
            return DnsOverride(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DnsOverride', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DnsOverride')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DnsOverride')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DnsOverride', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DnsOverride'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DnsOverride', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class DnsOverride


class WebAppHeaderList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppHeaderList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppHeaderList.subclass:
            return WebAppHeaderList.subclass(*args_, **kwargs_)
        else:
            return WebAppHeaderList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppHeaderList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppHeaderList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppHeaderList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppHeaderList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppHeaderList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppHeaderList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType24.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType25.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType26.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType27.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType28.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class WebAppHeaderList


class WebAppHeader(Cdata):
    subclass = None
    superclass = Cdata
    def __init__(self, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        super(WebAppHeader, self).__init__(valueOf_,  **kwargs_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppHeader.subclass:
            return WebAppHeader.subclass(*args_, **kwargs_)
        else:
            return WebAppHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(WebAppHeader, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppHeader', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppHeader')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppHeader')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppHeader', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppHeader'):
        super(WebAppHeader, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppHeader')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppHeader', fromsubclass_=False, pretty_print=True):
        super(WebAppHeader, self).exportChildren(outfile, level, namespaceprefix_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(WebAppHeader, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class WebAppHeader


class TagList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagList.subclass:
            return TagList.subclass(*args_, **kwargs_)
        else:
            return TagList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType29.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType30.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType31.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType32.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType33.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class TagList


class Tag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tag.subclass:
            return Tag.subclass(*args_, **kwargs_)
        else:
            return Tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Tag', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Tag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Tag'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class Tag


class CommentList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommentList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommentList.subclass:
            return CommentList.subclass(*args_, **kwargs_)
        else:
            return CommentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommentList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommentList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommentList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType34.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType35.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType36.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
# end class CommentList


class Comment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, contents=None, author=None, createdDate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.contents = contents
        self.author = author
        if isinstance(createdDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createdDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createdDate
        self.createdDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comment.subclass:
            return Comment.subclass(*args_, **kwargs_)
        else:
            return Comment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contents(self):
        return self.contents
    def set_contents(self, contents):
        self.contents = contents
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def get_createdDate(self):
        return self.createdDate
    def set_createdDate(self, createdDate):
        self.createdDate = createdDate
    def hasContent_(self):
        if (
            self.contents is not None or
            self.author is not None or
            self.createdDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Comment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Comment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Comment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contents is not None:
            self.contents.export(outfile, level, namespaceprefix_, namespacedef_, name_='contents', pretty_print=pretty_print)
        if self.author is not None:
            self.author.export(outfile, level, namespaceprefix_, name_='author', pretty_print=pretty_print)
        if self.createdDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.createdDate, input_name='createdDate'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contents':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.contents = obj_
            obj_.original_tagname_ = 'contents'
        elif nodeName_ == 'author':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.author = obj_
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'createdDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createdDate = dval_
# end class Comment


class WasScan(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WasScan)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WasScan.subclass:
            return WasScan.subclass(*args_, **kwargs_)
        else:
            return WasScan(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WasScan', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WasScan')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WasScan')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WasScan', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WasScan'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WasScan', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class WasScan


class TimeZone(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, code=None, offset=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.code = code
        self.offset = offset
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeZone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeZone.subclass:
            return TimeZone.subclass(*args_, **kwargs_)
        else:
            return TimeZone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_code(self):
        return self.code
    def set_code(self, code):
        self.code = code
    def get_offset(self):
        return self.offset
    def set_offset(self, offset):
        self.offset = offset
    def hasContent_(self):
        if (
            self.code is not None or
            self.offset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeZone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeZone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeZone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeZone', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeZone'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeZone', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scode>%s</%scode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.code), input_name='code')), namespaceprefix_ , eol_))
        if self.offset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soffset>%s</%soffset>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.offset), input_name='offset')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'code':
            code_ = child_.text
            code_ = self.gds_validate_string(code_, node, 'code')
            self.code = code_
        elif nodeName_ == 'offset':
            offset_ = child_.text
            offset_ = self.gds_validate_string(offset_, node, 'offset')
            self.offset = offset_
# end class TimeZone


class SchedulePlanification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, startDate=None, timeZone=None, occurrenceType=None, occurrence=None, cancelAfterNHours=None, cancelTime=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if isinstance(startDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        self.timeZone = timeZone
        self.occurrenceType = occurrenceType
        self.validate_occurrenceTypeType(self.occurrenceType)
        self.occurrence = occurrence
        self.cancelAfterNHours = cancelAfterNHours
        self.cancelTime = cancelTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SchedulePlanification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SchedulePlanification.subclass:
            return SchedulePlanification.subclass(*args_, **kwargs_)
        else:
            return SchedulePlanification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startDate(self):
        return self.startDate
    def set_startDate(self, startDate):
        self.startDate = startDate
    def get_timeZone(self):
        return self.timeZone
    def set_timeZone(self, timeZone):
        self.timeZone = timeZone
    def get_occurrenceType(self):
        return self.occurrenceType
    def set_occurrenceType(self, occurrenceType):
        self.occurrenceType = occurrenceType
    def get_occurrence(self):
        return self.occurrence
    def set_occurrence(self, occurrence):
        self.occurrence = occurrence
    def get_cancelAfterNHours(self):
        return self.cancelAfterNHours
    def set_cancelAfterNHours(self, cancelAfterNHours):
        self.cancelAfterNHours = cancelAfterNHours
    def get_cancelTime(self):
        return self.cancelTime
    def set_cancelTime(self, cancelTime):
        self.cancelTime = cancelTime
    def validate_occurrenceTypeType(self, value):
        # Validate type occurrenceTypeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ONCE', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on occurrenceTypeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.startDate is not None or
            self.timeZone is not None or
            self.occurrenceType is not None or
            self.occurrence is not None or
            self.cancelAfterNHours is not None or
            self.cancelTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SchedulePlanification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SchedulePlanification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SchedulePlanification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SchedulePlanification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SchedulePlanification'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SchedulePlanification', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartDate>%s</%sstartDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.startDate, input_name='startDate'), namespaceprefix_ , eol_))
        if self.timeZone is not None:
            self.timeZone.export(outfile, level, namespaceprefix_, name_='timeZone', pretty_print=pretty_print)
        if self.occurrenceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurrenceType>%s</%soccurrenceType>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.occurrenceType), input_name='occurrenceType')), namespaceprefix_ , eol_))
        if self.occurrence is not None:
            self.occurrence.export(outfile, level, namespaceprefix_, name_='occurrence', pretty_print=pretty_print)
        if self.cancelAfterNHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelAfterNHours>%s</%scancelAfterNHours>%s' % (namespaceprefix_ , self.gds_format_integer(self.cancelAfterNHours, input_name='cancelAfterNHours'), namespaceprefix_ , eol_))
        if self.cancelTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scancelTime>%s</%scancelTime>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cancelTime), input_name='cancelTime')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.startDate = dval_
        elif nodeName_ == 'timeZone':
            obj_ = TimeZone.factory(parent_object_=self)
            obj_.build(child_)
            self.timeZone = obj_
            obj_.original_tagname_ = 'timeZone'
        elif nodeName_ == 'occurrenceType':
            occurrenceType_ = child_.text
            occurrenceType_ = self.gds_validate_string(occurrenceType_, node, 'occurrenceType')
            self.occurrenceType = occurrenceType_
            # validate type occurrenceTypeType
            self.validate_occurrenceTypeType(self.occurrenceType)
        elif nodeName_ == 'occurrence':
            obj_ = occurrenceType37.factory(parent_object_=self)
            obj_.build(child_)
            self.occurrence = obj_
            obj_.original_tagname_ = 'occurrence'
        elif nodeName_ == 'cancelAfterNHours' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cancelAfterNHours')
            self.cancelAfterNHours = ival_
        elif nodeName_ == 'cancelTime':
            cancelTime_ = child_.text
            cancelTime_ = self.gds_validate_string(cancelTime_, node, 'cancelTime')
            self.cancelTime = cancelTime_
# end class SchedulePlanification


class HourlyOccurrence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, everyNHours=None, occurrenceCount=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.everyNHours = everyNHours
        self.occurrenceCount = occurrenceCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HourlyOccurrence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HourlyOccurrence.subclass:
            return HourlyOccurrence.subclass(*args_, **kwargs_)
        else:
            return HourlyOccurrence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_everyNHours(self):
        return self.everyNHours
    def set_everyNHours(self, everyNHours):
        self.everyNHours = everyNHours
    def get_occurrenceCount(self):
        return self.occurrenceCount
    def set_occurrenceCount(self, occurrenceCount):
        self.occurrenceCount = occurrenceCount
    def hasContent_(self):
        if (
            self.everyNHours is not None or
            self.occurrenceCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HourlyOccurrence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HourlyOccurrence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HourlyOccurrence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HourlyOccurrence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HourlyOccurrence'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HourlyOccurrence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.everyNHours is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyNHours>%s</%severyNHours>%s' % (namespaceprefix_ , self.gds_format_integer(self.everyNHours, input_name='everyNHours'), namespaceprefix_ , eol_))
        if self.occurrenceCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurrenceCount>%s</%soccurrenceCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.occurrenceCount, input_name='occurrenceCount'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'everyNHours' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'everyNHours')
            self.everyNHours = ival_
        elif nodeName_ == 'occurrenceCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'occurrenceCount')
            self.occurrenceCount = ival_
# end class HourlyOccurrence


class DailyOccurrence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, everyNDays=None, occurrenceCount=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.everyNDays = everyNDays
        self.occurrenceCount = occurrenceCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DailyOccurrence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DailyOccurrence.subclass:
            return DailyOccurrence.subclass(*args_, **kwargs_)
        else:
            return DailyOccurrence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_everyNDays(self):
        return self.everyNDays
    def set_everyNDays(self, everyNDays):
        self.everyNDays = everyNDays
    def get_occurrenceCount(self):
        return self.occurrenceCount
    def set_occurrenceCount(self, occurrenceCount):
        self.occurrenceCount = occurrenceCount
    def hasContent_(self):
        if (
            self.everyNDays is not None or
            self.occurrenceCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DailyOccurrence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DailyOccurrence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DailyOccurrence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DailyOccurrence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DailyOccurrence'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DailyOccurrence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.everyNDays is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyNDays>%s</%severyNDays>%s' % (namespaceprefix_ , self.gds_format_integer(self.everyNDays, input_name='everyNDays'), namespaceprefix_ , eol_))
        if self.occurrenceCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurrenceCount>%s</%soccurrenceCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.occurrenceCount, input_name='occurrenceCount'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'everyNDays' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'everyNDays')
            self.everyNDays = ival_
        elif nodeName_ == 'occurrenceCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'occurrenceCount')
            self.occurrenceCount = ival_
# end class DailyOccurrence


class WeeklyOccurrence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, everyNWeeks=None, onDays=None, occurrenceCount=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.everyNWeeks = everyNWeeks
        self.onDays = onDays
        self.occurrenceCount = occurrenceCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WeeklyOccurrence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WeeklyOccurrence.subclass:
            return WeeklyOccurrence.subclass(*args_, **kwargs_)
        else:
            return WeeklyOccurrence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_everyNWeeks(self):
        return self.everyNWeeks
    def set_everyNWeeks(self, everyNWeeks):
        self.everyNWeeks = everyNWeeks
    def get_onDays(self):
        return self.onDays
    def set_onDays(self, onDays):
        self.onDays = onDays
    def get_occurrenceCount(self):
        return self.occurrenceCount
    def set_occurrenceCount(self, occurrenceCount):
        self.occurrenceCount = occurrenceCount
    def hasContent_(self):
        if (
            self.everyNWeeks is not None or
            self.onDays is not None or
            self.occurrenceCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WeeklyOccurrence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WeeklyOccurrence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WeeklyOccurrence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WeeklyOccurrence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WeeklyOccurrence'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WeeklyOccurrence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.everyNWeeks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyNWeeks>%s</%severyNWeeks>%s' % (namespaceprefix_ , self.gds_format_integer(self.everyNWeeks, input_name='everyNWeeks'), namespaceprefix_ , eol_))
        if self.onDays is not None:
            self.onDays.export(outfile, level, namespaceprefix_, name_='onDays', pretty_print=pretty_print)
        if self.occurrenceCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurrenceCount>%s</%soccurrenceCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.occurrenceCount, input_name='occurrenceCount'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'everyNWeeks' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'everyNWeeks')
            self.everyNWeeks = ival_
        elif nodeName_ == 'onDays':
            obj_ = onDaysType.factory(parent_object_=self)
            obj_.build(child_)
            self.onDays = obj_
            obj_.original_tagname_ = 'onDays'
        elif nodeName_ == 'occurrenceCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'occurrenceCount')
            self.occurrenceCount = ival_
# end class WeeklyOccurrence


class MonthlyOccurrence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, monthlyType=None, occurrenceCount=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.monthlyType = monthlyType
        self.occurrenceCount = occurrenceCount
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MonthlyOccurrence)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MonthlyOccurrence.subclass:
            return MonthlyOccurrence.subclass(*args_, **kwargs_)
        else:
            return MonthlyOccurrence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_monthlyType(self):
        return self.monthlyType
    def set_monthlyType(self, monthlyType):
        self.monthlyType = monthlyType
    def get_occurrenceCount(self):
        return self.occurrenceCount
    def set_occurrenceCount(self, occurrenceCount):
        self.occurrenceCount = occurrenceCount
    def hasContent_(self):
        if (
            self.monthlyType is not None or
            self.occurrenceCount is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MonthlyOccurrence', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MonthlyOccurrence')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MonthlyOccurrence')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MonthlyOccurrence', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MonthlyOccurrence'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MonthlyOccurrence', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.monthlyType is not None:
            self.monthlyType.export(outfile, level, namespaceprefix_, name_='monthlyType', pretty_print=pretty_print)
        if self.occurrenceCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soccurrenceCount>%s</%soccurrenceCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.occurrenceCount, input_name='occurrenceCount'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'monthlyType':
            obj_ = monthlyTypeType.factory(parent_object_=self)
            obj_.build(child_)
            self.monthlyType = obj_
            obj_.original_tagname_ = 'monthlyType'
        elif nodeName_ == 'occurrenceCount' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'occurrenceCount')
            self.occurrenceCount = ival_
# end class MonthlyOccurrence


class CrawlingScriptList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CrawlingScriptList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CrawlingScriptList.subclass:
            return CrawlingScriptList.subclass(*args_, **kwargs_)
        else:
            return CrawlingScriptList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CrawlingScriptList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CrawlingScriptList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CrawlingScriptList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CrawlingScriptList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CrawlingScriptList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CrawlingScriptList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType38.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType39.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType40.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType41.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType42.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class CrawlingScriptList


class SeleniumScript(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, data=None, regex=None, requiresAuthentication=None, startingUrl=None, startingUrlRegex=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
        self.data = data
        self.regex = regex
        self.requiresAuthentication = requiresAuthentication
        self.startingUrl = startingUrl
        self.startingUrlRegex = startingUrlRegex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeleniumScript)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeleniumScript.subclass:
            return SeleniumScript.subclass(*args_, **kwargs_)
        else:
            return SeleniumScript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def get_regex(self):
        return self.regex
    def set_regex(self, regex):
        self.regex = regex
    def get_requiresAuthentication(self):
        return self.requiresAuthentication
    def set_requiresAuthentication(self, requiresAuthentication):
        self.requiresAuthentication = requiresAuthentication
    def get_startingUrl(self):
        return self.startingUrl
    def set_startingUrl(self, startingUrl):
        self.startingUrl = startingUrl
    def get_startingUrlRegex(self):
        return self.startingUrlRegex
    def set_startingUrlRegex(self, startingUrlRegex):
        self.startingUrlRegex = startingUrlRegex
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.data is not None or
            self.regex is not None or
            self.requiresAuthentication is not None or
            self.startingUrl is not None or
            self.startingUrlRegex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeleniumScript', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeleniumScript')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SeleniumScript')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SeleniumScript', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SeleniumScript'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeleniumScript', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
        if self.regex is not None:
            self.regex.export(outfile, level, namespaceprefix_, name_='regex', pretty_print=pretty_print)
        if self.requiresAuthentication is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequiresAuthentication>%s</%srequiresAuthentication>%s' % (namespaceprefix_ , self.gds_format_boolean(self.requiresAuthentication, input_name='requiresAuthentication'), namespaceprefix_ , eol_))
        if self.startingUrl is not None:
            self.startingUrl.export(outfile, level, namespaceprefix_, name_='startingUrl', pretty_print=pretty_print)
        if self.startingUrlRegex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartingUrlRegex>%s</%sstartingUrlRegex>%s' % (namespaceprefix_ , self.gds_format_boolean(self.startingUrlRegex, input_name='startingUrlRegex'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'data':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
        elif nodeName_ == 'regex':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.regex = obj_
            obj_.original_tagname_ = 'regex'
        elif nodeName_ == 'requiresAuthentication':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'requiresAuthentication')
            self.requiresAuthentication = ival_
        elif nodeName_ == 'startingUrl':
            class_obj_ = self.get_class_obj_(child_, Cdata)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_)
            self.startingUrl = obj_
            obj_.original_tagname_ = 'startingUrl'
        elif nodeName_ == 'startingUrlRegex':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'startingUrlRegex')
            self.startingUrlRegex = ival_
# end class SeleniumScript


class listType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Url is None:
            self.Url = []
        else:
            self.Url = Url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType.subclass:
            return listType.subclass(*args_, **kwargs_)
        else:
            return listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Url(self):
        return self.Url
    def set_Url(self, Url):
        self.Url = Url
    def add_Url(self, value):
        self.Url.append(value)
    def add_Url(self, value):
        self.Url.append(value)
    def insert_Url_at(self, index, value):
        self.Url.insert(index, value)
    def replace_Url_at(self, index, value):
        self.Url[index] = value
    def hasContent_(self):
        if (
            self.Url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Url_ in self.Url:
            Url_.export(outfile, level, namespaceprefix_, name_='Url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.Url.append(obj_)
            obj_.original_tagname_ = 'Url'
# end class listType


class setType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Url is None:
            self.Url = []
        else:
            self.Url = Url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType.subclass:
            return setType.subclass(*args_, **kwargs_)
        else:
            return setType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Url(self):
        return self.Url
    def set_Url(self, Url):
        self.Url = Url
    def add_Url(self, value):
        self.Url.append(value)
    def add_Url(self, value):
        self.Url.append(value)
    def insert_Url_at(self, index, value):
        self.Url.insert(index, value)
    def replace_Url_at(self, index, value):
        self.Url[index] = value
    def hasContent_(self):
        if (
            self.Url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Url_ in self.Url:
            Url_.export(outfile, level, namespaceprefix_, name_='Url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.Url.append(obj_)
            obj_.original_tagname_ = 'Url'
# end class setType


class addType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Url is None:
            self.Url = []
        else:
            self.Url = Url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType.subclass:
            return addType.subclass(*args_, **kwargs_)
        else:
            return addType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Url(self):
        return self.Url
    def set_Url(self, Url):
        self.Url = Url
    def add_Url(self, value):
        self.Url.append(value)
    def add_Url(self, value):
        self.Url.append(value)
    def insert_Url_at(self, index, value):
        self.Url.insert(index, value)
    def replace_Url_at(self, index, value):
        self.Url[index] = value
    def hasContent_(self):
        if (
            self.Url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Url_ in self.Url:
            Url_.export(outfile, level, namespaceprefix_, name_='Url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.Url.append(obj_)
            obj_.original_tagname_ = 'Url'
# end class addType


class removeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Url is None:
            self.Url = []
        else:
            self.Url = Url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType.subclass:
            return removeType.subclass(*args_, **kwargs_)
        else:
            return removeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Url(self):
        return self.Url
    def set_Url(self, Url):
        self.Url = Url
    def add_Url(self, value):
        self.Url.append(value)
    def add_Url(self, value):
        self.Url.append(value)
    def insert_Url_at(self, index, value):
        self.Url.insert(index, value)
    def replace_Url_at(self, index, value):
        self.Url[index] = value
    def hasContent_(self):
        if (
            self.Url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Url_ in self.Url:
            Url_.export(outfile, level, namespaceprefix_, name_='Url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.Url.append(obj_)
            obj_.original_tagname_ = 'Url'
# end class removeType


class updateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Url=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Url is None:
            self.Url = []
        else:
            self.Url = Url
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType.subclass:
            return updateType.subclass(*args_, **kwargs_)
        else:
            return updateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Url(self):
        return self.Url
    def set_Url(self, Url):
        self.Url = Url
    def add_Url(self, value):
        self.Url.append(value)
    def add_Url(self, value):
        self.Url.append(value)
    def insert_Url_at(self, index, value):
        self.Url.insert(index, value)
    def replace_Url_at(self, index, value):
        self.Url[index] = value
    def hasContent_(self):
        if (
            self.Url
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Url_ in self.Url:
            Url_.export(outfile, level, namespaceprefix_, name_='Url', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Url':
            obj_ = Url.factory(parent_object_=self)
            obj_.build(child_)
            self.Url.append(obj_)
            obj_.original_tagname_ = 'Url'
# end class updateType


class listType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType1.subclass:
            return listType1.subclass(*args_, **kwargs_)
        else:
            return listType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def add_Domain(self, value):
        self.Domain.append(value)
    def add_Domain(self, value):
        self.Domain.append(value)
    def insert_Domain_at(self, index, value):
        self.Domain.insert(index, value)
    def replace_Domain_at(self, index, value):
        self.Domain[index] = value
    def hasContent_(self):
        if (
            self.Domain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespaceprefix_, name_='Domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
# end class listType1


class setType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType2.subclass:
            return setType2.subclass(*args_, **kwargs_)
        else:
            return setType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def add_Domain(self, value):
        self.Domain.append(value)
    def add_Domain(self, value):
        self.Domain.append(value)
    def insert_Domain_at(self, index, value):
        self.Domain.insert(index, value)
    def replace_Domain_at(self, index, value):
        self.Domain[index] = value
    def hasContent_(self):
        if (
            self.Domain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType2'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespaceprefix_, name_='Domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
# end class setType2


class addType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType3.subclass:
            return addType3.subclass(*args_, **kwargs_)
        else:
            return addType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def add_Domain(self, value):
        self.Domain.append(value)
    def add_Domain(self, value):
        self.Domain.append(value)
    def insert_Domain_at(self, index, value):
        self.Domain.insert(index, value)
    def replace_Domain_at(self, index, value):
        self.Domain[index] = value
    def hasContent_(self):
        if (
            self.Domain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespaceprefix_, name_='Domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
# end class addType3


class removeType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType4.subclass:
            return removeType4.subclass(*args_, **kwargs_)
        else:
            return removeType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def add_Domain(self, value):
        self.Domain.append(value)
    def add_Domain(self, value):
        self.Domain.append(value)
    def insert_Domain_at(self, index, value):
        self.Domain.insert(index, value)
    def replace_Domain_at(self, index, value):
        self.Domain[index] = value
    def hasContent_(self):
        if (
            self.Domain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType4'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespaceprefix_, name_='Domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
# end class removeType4


class updateType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Domain=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Domain is None:
            self.Domain = []
        else:
            self.Domain = Domain
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType5.subclass:
            return updateType5.subclass(*args_, **kwargs_)
        else:
            return updateType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self):
        return self.Domain
    def set_Domain(self, Domain):
        self.Domain = Domain
    def add_Domain(self, value):
        self.Domain.append(value)
    def add_Domain(self, value):
        self.Domain.append(value)
    def insert_Domain_at(self, index, value):
        self.Domain.insert(index, value)
    def replace_Domain_at(self, index, value):
        self.Domain[index] = value
    def hasContent_(self):
        if (
            self.Domain
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType5'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Domain_ in self.Domain:
            Domain_.export(outfile, level, namespaceprefix_, name_='Domain', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = Domain.factory(parent_object_=self)
            obj_.build(child_)
            self.Domain.append(obj_)
            obj_.original_tagname_ = 'Domain'
# end class updateType5


class listType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType6)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType6.subclass:
            return listType6.subclass(*args_, **kwargs_)
        else:
            return listType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self):
        return self.Attribute
    def set_Attribute(self, Attribute):
        self.Attribute = Attribute
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def insert_Attribute_at(self, index, value):
        self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value):
        self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType6', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType6')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType6'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespaceprefix_, name_='Attribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory(parent_object_=self)
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class listType6


class setType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType7.subclass:
            return setType7.subclass(*args_, **kwargs_)
        else:
            return setType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self):
        return self.Attribute
    def set_Attribute(self, Attribute):
        self.Attribute = Attribute
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def insert_Attribute_at(self, index, value):
        self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value):
        self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType7'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespaceprefix_, name_='Attribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory(parent_object_=self)
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class setType7


class addType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType8.subclass:
            return addType8.subclass(*args_, **kwargs_)
        else:
            return addType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self):
        return self.Attribute
    def set_Attribute(self, Attribute):
        self.Attribute = Attribute
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def insert_Attribute_at(self, index, value):
        self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value):
        self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType8'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespaceprefix_, name_='Attribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory(parent_object_=self)
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class addType8


class removeType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType9.subclass:
            return removeType9.subclass(*args_, **kwargs_)
        else:
            return removeType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self):
        return self.Attribute
    def set_Attribute(self, Attribute):
        self.Attribute = Attribute
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def insert_Attribute_at(self, index, value):
        self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value):
        self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType9'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespaceprefix_, name_='Attribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory(parent_object_=self)
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class removeType9


class updateType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Attribute=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType10.subclass:
            return updateType10.subclass(*args_, **kwargs_)
        else:
            return updateType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Attribute(self):
        return self.Attribute
    def set_Attribute(self, Attribute):
        self.Attribute = Attribute
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def add_Attribute(self, value):
        self.Attribute.append(value)
    def insert_Attribute_at(self, index, value):
        self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value):
        self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType10'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespaceprefix_, name_='Attribute', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Attribute':
            obj_ = Attribute.factory(parent_object_=self)
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class updateType10


class listType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrlEntry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if UrlEntry is None:
            self.UrlEntry = []
        else:
            self.UrlEntry = UrlEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType11.subclass:
            return listType11.subclass(*args_, **kwargs_)
        else:
            return listType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrlEntry(self):
        return self.UrlEntry
    def set_UrlEntry(self, UrlEntry):
        self.UrlEntry = UrlEntry
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def insert_UrlEntry_at(self, index, value):
        self.UrlEntry.insert(index, value)
    def replace_UrlEntry_at(self, index, value):
        self.UrlEntry[index] = value
    def hasContent_(self):
        if (
            self.UrlEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType11'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UrlEntry_ in self.UrlEntry:
            UrlEntry_.export(outfile, level, namespaceprefix_, name_='UrlEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrlEntry':
            obj_ = UrlEntry.factory(parent_object_=self)
            obj_.build(child_)
            self.UrlEntry.append(obj_)
            obj_.original_tagname_ = 'UrlEntry'
# end class listType11


class setType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrlEntry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if UrlEntry is None:
            self.UrlEntry = []
        else:
            self.UrlEntry = UrlEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType12.subclass:
            return setType12.subclass(*args_, **kwargs_)
        else:
            return setType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrlEntry(self):
        return self.UrlEntry
    def set_UrlEntry(self, UrlEntry):
        self.UrlEntry = UrlEntry
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def insert_UrlEntry_at(self, index, value):
        self.UrlEntry.insert(index, value)
    def replace_UrlEntry_at(self, index, value):
        self.UrlEntry[index] = value
    def hasContent_(self):
        if (
            self.UrlEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType12'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UrlEntry_ in self.UrlEntry:
            UrlEntry_.export(outfile, level, namespaceprefix_, name_='UrlEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrlEntry':
            obj_ = UrlEntry.factory(parent_object_=self)
            obj_.build(child_)
            self.UrlEntry.append(obj_)
            obj_.original_tagname_ = 'UrlEntry'
# end class setType12


class addType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrlEntry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if UrlEntry is None:
            self.UrlEntry = []
        else:
            self.UrlEntry = UrlEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType13.subclass:
            return addType13.subclass(*args_, **kwargs_)
        else:
            return addType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrlEntry(self):
        return self.UrlEntry
    def set_UrlEntry(self, UrlEntry):
        self.UrlEntry = UrlEntry
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def insert_UrlEntry_at(self, index, value):
        self.UrlEntry.insert(index, value)
    def replace_UrlEntry_at(self, index, value):
        self.UrlEntry[index] = value
    def hasContent_(self):
        if (
            self.UrlEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType13'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UrlEntry_ in self.UrlEntry:
            UrlEntry_.export(outfile, level, namespaceprefix_, name_='UrlEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrlEntry':
            obj_ = UrlEntry.factory(parent_object_=self)
            obj_.build(child_)
            self.UrlEntry.append(obj_)
            obj_.original_tagname_ = 'UrlEntry'
# end class addType13


class removeType14(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrlEntry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if UrlEntry is None:
            self.UrlEntry = []
        else:
            self.UrlEntry = UrlEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType14)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType14.subclass:
            return removeType14.subclass(*args_, **kwargs_)
        else:
            return removeType14(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrlEntry(self):
        return self.UrlEntry
    def set_UrlEntry(self, UrlEntry):
        self.UrlEntry = UrlEntry
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def insert_UrlEntry_at(self, index, value):
        self.UrlEntry.insert(index, value)
    def replace_UrlEntry_at(self, index, value):
        self.UrlEntry[index] = value
    def hasContent_(self):
        if (
            self.UrlEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType14', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType14')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType14')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType14', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType14'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType14', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UrlEntry_ in self.UrlEntry:
            UrlEntry_.export(outfile, level, namespaceprefix_, name_='UrlEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrlEntry':
            obj_ = UrlEntry.factory(parent_object_=self)
            obj_.build(child_)
            self.UrlEntry.append(obj_)
            obj_.original_tagname_ = 'UrlEntry'
# end class removeType14


class updateType15(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UrlEntry=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if UrlEntry is None:
            self.UrlEntry = []
        else:
            self.UrlEntry = UrlEntry
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType15)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType15.subclass:
            return updateType15.subclass(*args_, **kwargs_)
        else:
            return updateType15(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UrlEntry(self):
        return self.UrlEntry
    def set_UrlEntry(self, UrlEntry):
        self.UrlEntry = UrlEntry
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def add_UrlEntry(self, value):
        self.UrlEntry.append(value)
    def insert_UrlEntry_at(self, index, value):
        self.UrlEntry.insert(index, value)
    def replace_UrlEntry_at(self, index, value):
        self.UrlEntry[index] = value
    def hasContent_(self):
        if (
            self.UrlEntry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType15', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType15')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType15')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType15', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType15'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType15', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UrlEntry_ in self.UrlEntry:
            UrlEntry_.export(outfile, level, namespaceprefix_, name_='UrlEntry', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UrlEntry':
            obj_ = UrlEntry.factory(parent_object_=self)
            obj_.build(child_)
            self.UrlEntry.append(obj_)
            obj_.original_tagname_ = 'UrlEntry'
# end class updateType15


class listType16(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthRecord is None:
            self.WebAppAuthRecord = []
        else:
            self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType16)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType16.subclass:
            return listType16.subclass(*args_, **kwargs_)
        else:
            return listType16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def insert_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord.insert(index, value)
    def replace_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType16', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType16')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType16')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType16', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType16'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType16', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthRecord_ in self.WebAppAuthRecord:
            WebAppAuthRecord_.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class listType16


class setType17(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthRecord is None:
            self.WebAppAuthRecord = []
        else:
            self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType17)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType17.subclass:
            return setType17.subclass(*args_, **kwargs_)
        else:
            return setType17(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def insert_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord.insert(index, value)
    def replace_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType17', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType17')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType17')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType17', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType17'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType17', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthRecord_ in self.WebAppAuthRecord:
            WebAppAuthRecord_.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class setType17


class addType18(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthRecord is None:
            self.WebAppAuthRecord = []
        else:
            self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType18)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType18.subclass:
            return addType18.subclass(*args_, **kwargs_)
        else:
            return addType18(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def insert_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord.insert(index, value)
    def replace_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType18', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType18')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType18')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType18', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType18'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType18', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthRecord_ in self.WebAppAuthRecord:
            WebAppAuthRecord_.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class addType18


class removeType19(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthRecord is None:
            self.WebAppAuthRecord = []
        else:
            self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType19)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType19.subclass:
            return removeType19.subclass(*args_, **kwargs_)
        else:
            return removeType19(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def insert_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord.insert(index, value)
    def replace_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType19', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType19')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType19')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType19', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType19'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType19', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthRecord_ in self.WebAppAuthRecord:
            WebAppAuthRecord_.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class removeType19


class listType20(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DnsOverride=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if DnsOverride is None:
            self.DnsOverride = []
        else:
            self.DnsOverride = DnsOverride
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType20)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType20.subclass:
            return listType20.subclass(*args_, **kwargs_)
        else:
            return listType20(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DnsOverride(self):
        return self.DnsOverride
    def set_DnsOverride(self, DnsOverride):
        self.DnsOverride = DnsOverride
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def insert_DnsOverride_at(self, index, value):
        self.DnsOverride.insert(index, value)
    def replace_DnsOverride_at(self, index, value):
        self.DnsOverride[index] = value
    def hasContent_(self):
        if (
            self.DnsOverride
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType20', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType20')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType20')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType20', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType20'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType20', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DnsOverride_ in self.DnsOverride:
            DnsOverride_.export(outfile, level, namespaceprefix_, name_='DnsOverride', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DnsOverride':
            obj_ = DnsOverride.factory(parent_object_=self)
            obj_.build(child_)
            self.DnsOverride.append(obj_)
            obj_.original_tagname_ = 'DnsOverride'
# end class listType20


class setType21(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DnsOverride=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if DnsOverride is None:
            self.DnsOverride = []
        else:
            self.DnsOverride = DnsOverride
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType21)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType21.subclass:
            return setType21.subclass(*args_, **kwargs_)
        else:
            return setType21(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DnsOverride(self):
        return self.DnsOverride
    def set_DnsOverride(self, DnsOverride):
        self.DnsOverride = DnsOverride
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def insert_DnsOverride_at(self, index, value):
        self.DnsOverride.insert(index, value)
    def replace_DnsOverride_at(self, index, value):
        self.DnsOverride[index] = value
    def hasContent_(self):
        if (
            self.DnsOverride
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType21', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType21')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType21')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType21', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType21'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType21', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DnsOverride_ in self.DnsOverride:
            DnsOverride_.export(outfile, level, namespaceprefix_, name_='DnsOverride', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DnsOverride':
            obj_ = DnsOverride.factory(parent_object_=self)
            obj_.build(child_)
            self.DnsOverride.append(obj_)
            obj_.original_tagname_ = 'DnsOverride'
# end class setType21


class addType22(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DnsOverride=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if DnsOverride is None:
            self.DnsOverride = []
        else:
            self.DnsOverride = DnsOverride
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType22)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType22.subclass:
            return addType22.subclass(*args_, **kwargs_)
        else:
            return addType22(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DnsOverride(self):
        return self.DnsOverride
    def set_DnsOverride(self, DnsOverride):
        self.DnsOverride = DnsOverride
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def insert_DnsOverride_at(self, index, value):
        self.DnsOverride.insert(index, value)
    def replace_DnsOverride_at(self, index, value):
        self.DnsOverride[index] = value
    def hasContent_(self):
        if (
            self.DnsOverride
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType22', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType22')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType22')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType22', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType22'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType22', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DnsOverride_ in self.DnsOverride:
            DnsOverride_.export(outfile, level, namespaceprefix_, name_='DnsOverride', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DnsOverride':
            obj_ = DnsOverride.factory(parent_object_=self)
            obj_.build(child_)
            self.DnsOverride.append(obj_)
            obj_.original_tagname_ = 'DnsOverride'
# end class addType22


class removeType23(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DnsOverride=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if DnsOverride is None:
            self.DnsOverride = []
        else:
            self.DnsOverride = DnsOverride
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType23)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType23.subclass:
            return removeType23.subclass(*args_, **kwargs_)
        else:
            return removeType23(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DnsOverride(self):
        return self.DnsOverride
    def set_DnsOverride(self, DnsOverride):
        self.DnsOverride = DnsOverride
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def add_DnsOverride(self, value):
        self.DnsOverride.append(value)
    def insert_DnsOverride_at(self, index, value):
        self.DnsOverride.insert(index, value)
    def replace_DnsOverride_at(self, index, value):
        self.DnsOverride[index] = value
    def hasContent_(self):
        if (
            self.DnsOverride
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType23', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType23')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType23')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType23', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType23'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType23', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DnsOverride_ in self.DnsOverride:
            DnsOverride_.export(outfile, level, namespaceprefix_, name_='DnsOverride', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DnsOverride':
            obj_ = DnsOverride.factory(parent_object_=self)
            obj_.build(child_)
            self.DnsOverride.append(obj_)
            obj_.original_tagname_ = 'DnsOverride'
# end class removeType23


class listType24(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppHeader=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppHeader is None:
            self.WebAppHeader = []
        else:
            self.WebAppHeader = WebAppHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType24)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType24.subclass:
            return listType24.subclass(*args_, **kwargs_)
        else:
            return listType24(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppHeader(self):
        return self.WebAppHeader
    def set_WebAppHeader(self, WebAppHeader):
        self.WebAppHeader = WebAppHeader
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def insert_WebAppHeader_at(self, index, value):
        self.WebAppHeader.insert(index, value)
    def replace_WebAppHeader_at(self, index, value):
        self.WebAppHeader[index] = value
    def hasContent_(self):
        if (
            self.WebAppHeader
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType24', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType24')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType24')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType24', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType24'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType24', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppHeader_ in self.WebAppHeader:
            WebAppHeader_.export(outfile, level, namespaceprefix_, name_='WebAppHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppHeader':
            obj_ = WebAppHeader.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppHeader.append(obj_)
            obj_.original_tagname_ = 'WebAppHeader'
# end class listType24


class setType25(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppHeader=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppHeader is None:
            self.WebAppHeader = []
        else:
            self.WebAppHeader = WebAppHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType25)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType25.subclass:
            return setType25.subclass(*args_, **kwargs_)
        else:
            return setType25(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppHeader(self):
        return self.WebAppHeader
    def set_WebAppHeader(self, WebAppHeader):
        self.WebAppHeader = WebAppHeader
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def insert_WebAppHeader_at(self, index, value):
        self.WebAppHeader.insert(index, value)
    def replace_WebAppHeader_at(self, index, value):
        self.WebAppHeader[index] = value
    def hasContent_(self):
        if (
            self.WebAppHeader
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType25', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType25')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType25')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType25', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType25'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType25', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppHeader_ in self.WebAppHeader:
            WebAppHeader_.export(outfile, level, namespaceprefix_, name_='WebAppHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppHeader':
            obj_ = WebAppHeader.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppHeader.append(obj_)
            obj_.original_tagname_ = 'WebAppHeader'
# end class setType25


class addType26(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppHeader=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppHeader is None:
            self.WebAppHeader = []
        else:
            self.WebAppHeader = WebAppHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType26)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType26.subclass:
            return addType26.subclass(*args_, **kwargs_)
        else:
            return addType26(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppHeader(self):
        return self.WebAppHeader
    def set_WebAppHeader(self, WebAppHeader):
        self.WebAppHeader = WebAppHeader
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def insert_WebAppHeader_at(self, index, value):
        self.WebAppHeader.insert(index, value)
    def replace_WebAppHeader_at(self, index, value):
        self.WebAppHeader[index] = value
    def hasContent_(self):
        if (
            self.WebAppHeader
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType26', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType26')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType26')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType26', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType26'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType26', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppHeader_ in self.WebAppHeader:
            WebAppHeader_.export(outfile, level, namespaceprefix_, name_='WebAppHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppHeader':
            obj_ = WebAppHeader.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppHeader.append(obj_)
            obj_.original_tagname_ = 'WebAppHeader'
# end class addType26


class removeType27(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppHeader=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppHeader is None:
            self.WebAppHeader = []
        else:
            self.WebAppHeader = WebAppHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType27)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType27.subclass:
            return removeType27.subclass(*args_, **kwargs_)
        else:
            return removeType27(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppHeader(self):
        return self.WebAppHeader
    def set_WebAppHeader(self, WebAppHeader):
        self.WebAppHeader = WebAppHeader
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def insert_WebAppHeader_at(self, index, value):
        self.WebAppHeader.insert(index, value)
    def replace_WebAppHeader_at(self, index, value):
        self.WebAppHeader[index] = value
    def hasContent_(self):
        if (
            self.WebAppHeader
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType27', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType27')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType27')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType27', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType27'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType27', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppHeader_ in self.WebAppHeader:
            WebAppHeader_.export(outfile, level, namespaceprefix_, name_='WebAppHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppHeader':
            obj_ = WebAppHeader.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppHeader.append(obj_)
            obj_.original_tagname_ = 'WebAppHeader'
# end class removeType27


class updateType28(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppHeader=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppHeader is None:
            self.WebAppHeader = []
        else:
            self.WebAppHeader = WebAppHeader
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType28)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType28.subclass:
            return updateType28.subclass(*args_, **kwargs_)
        else:
            return updateType28(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppHeader(self):
        return self.WebAppHeader
    def set_WebAppHeader(self, WebAppHeader):
        self.WebAppHeader = WebAppHeader
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def add_WebAppHeader(self, value):
        self.WebAppHeader.append(value)
    def insert_WebAppHeader_at(self, index, value):
        self.WebAppHeader.insert(index, value)
    def replace_WebAppHeader_at(self, index, value):
        self.WebAppHeader[index] = value
    def hasContent_(self):
        if (
            self.WebAppHeader
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType28', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType28')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType28')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType28', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType28'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType28', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppHeader_ in self.WebAppHeader:
            WebAppHeader_.export(outfile, level, namespaceprefix_, name_='WebAppHeader', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppHeader':
            obj_ = WebAppHeader.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppHeader.append(obj_)
            obj_.original_tagname_ = 'WebAppHeader'
# end class updateType28


class listType29(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType29)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType29.subclass:
            return listType29.subclass(*args_, **kwargs_)
        else:
            return listType29(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType29', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType29')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType29')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType29', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType29'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType29', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class listType29


class setType30(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType30)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType30.subclass:
            return setType30.subclass(*args_, **kwargs_)
        else:
            return setType30(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType30', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType30')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType30')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType30', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType30'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType30', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class setType30


class addType31(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType31)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType31.subclass:
            return addType31.subclass(*args_, **kwargs_)
        else:
            return addType31(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType31', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType31')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType31')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType31', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType31'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType31', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class addType31


class removeType32(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType32)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType32.subclass:
            return removeType32.subclass(*args_, **kwargs_)
        else:
            return removeType32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType32', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType32')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType32')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType32', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType32'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType32', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class removeType32


class updateType33(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType33)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType33.subclass:
            return updateType33.subclass(*args_, **kwargs_)
        else:
            return updateType33(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType33', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType33')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType33')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType33', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType33'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType33', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class updateType33


class listType34(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType34)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType34.subclass:
            return listType34.subclass(*args_, **kwargs_)
        else:
            return listType34(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType34', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType34')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType34')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType34', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType34'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType34', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class listType34


class setType35(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType35)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType35.subclass:
            return setType35.subclass(*args_, **kwargs_)
        else:
            return setType35(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType35', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType35')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType35')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType35', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType35'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType35', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class setType35


class addType36(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType36)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType36.subclass:
            return addType36.subclass(*args_, **kwargs_)
        else:
            return addType36(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType36', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType36')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType36')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType36', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType36'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType36', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class addType36


class occurrenceType37(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hourlyOccurrence=None, dailyOccurrence=None, weeklyOccurrence=None, monthlyOccurrence=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.hourlyOccurrence = hourlyOccurrence
        self.dailyOccurrence = dailyOccurrence
        self.weeklyOccurrence = weeklyOccurrence
        self.monthlyOccurrence = monthlyOccurrence
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, occurrenceType37)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if occurrenceType37.subclass:
            return occurrenceType37.subclass(*args_, **kwargs_)
        else:
            return occurrenceType37(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hourlyOccurrence(self):
        return self.hourlyOccurrence
    def set_hourlyOccurrence(self, hourlyOccurrence):
        self.hourlyOccurrence = hourlyOccurrence
    def get_dailyOccurrence(self):
        return self.dailyOccurrence
    def set_dailyOccurrence(self, dailyOccurrence):
        self.dailyOccurrence = dailyOccurrence
    def get_weeklyOccurrence(self):
        return self.weeklyOccurrence
    def set_weeklyOccurrence(self, weeklyOccurrence):
        self.weeklyOccurrence = weeklyOccurrence
    def get_monthlyOccurrence(self):
        return self.monthlyOccurrence
    def set_monthlyOccurrence(self, monthlyOccurrence):
        self.monthlyOccurrence = monthlyOccurrence
    def hasContent_(self):
        if (
            self.hourlyOccurrence is not None or
            self.dailyOccurrence is not None or
            self.weeklyOccurrence is not None or
            self.monthlyOccurrence is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurrenceType37', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('occurrenceType37')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='occurrenceType37')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='occurrenceType37', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='occurrenceType37'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurrenceType37', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.hourlyOccurrence is not None:
            self.hourlyOccurrence.export(outfile, level, namespaceprefix_, namespacedef_, name_='hourlyOccurrence', pretty_print=pretty_print)
        if self.dailyOccurrence is not None:
            self.dailyOccurrence.export(outfile, level, namespaceprefix_, namespacedef_, name_='dailyOccurrence', pretty_print=pretty_print)
        if self.weeklyOccurrence is not None:
            self.weeklyOccurrence.export(outfile, level, namespaceprefix_, namespacedef_, name_='weeklyOccurrence', pretty_print=pretty_print)
        if self.monthlyOccurrence is not None:
            self.monthlyOccurrence.export(outfile, level, namespaceprefix_, namespacedef_, name_='monthlyOccurrence', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'hourlyOccurrence':
            obj_ = HourlyOccurrence.factory(parent_object_=self)
            obj_.build(child_)
            self.hourlyOccurrence = obj_
            obj_.original_tagname_ = 'hourlyOccurrence'
        elif nodeName_ == 'dailyOccurrence':
            obj_ = DailyOccurrence.factory(parent_object_=self)
            obj_.build(child_)
            self.dailyOccurrence = obj_
            obj_.original_tagname_ = 'dailyOccurrence'
        elif nodeName_ == 'weeklyOccurrence':
            obj_ = WeeklyOccurrence.factory(parent_object_=self)
            obj_.build(child_)
            self.weeklyOccurrence = obj_
            obj_.original_tagname_ = 'weeklyOccurrence'
        elif nodeName_ == 'monthlyOccurrence':
            obj_ = MonthlyOccurrence.factory(parent_object_=self)
            obj_.build(child_)
            self.monthlyOccurrence = obj_
            obj_.original_tagname_ = 'monthlyOccurrence'
# end class occurrenceType37


class onDaysType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WeekDay=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WeekDay is None:
            self.WeekDay = []
        else:
            self.WeekDay = WeekDay
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, onDaysType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if onDaysType.subclass:
            return onDaysType.subclass(*args_, **kwargs_)
        else:
            return onDaysType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WeekDay(self):
        return self.WeekDay
    def set_WeekDay(self, WeekDay):
        self.WeekDay = WeekDay
    def add_WeekDay(self, value):
        self.WeekDay.append(value)
    def add_WeekDay(self, value):
        self.WeekDay.append(value)
    def insert_WeekDay_at(self, index, value):
        self.WeekDay.insert(index, value)
    def replace_WeekDay_at(self, index, value):
        self.WeekDay[index] = value
    def validate_WeekDay(self, value):
        # Validate type WeekDay, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeekDay' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.WeekDay
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='onDaysType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('onDaysType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='onDaysType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='onDaysType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='onDaysType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='onDaysType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WeekDay_ in self.WeekDay:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeekDay>%s</%sWeekDay>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(WeekDay_), input_name='WeekDay')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WeekDay':
            WeekDay_ = child_.text
            WeekDay_ = self.gds_validate_string(WeekDay_, node, 'WeekDay')
            self.WeekDay.append(WeekDay_)
            # validate type WeekDay
            self.validate_WeekDay(self.WeekDay[-1])
# end class onDaysType


class monthlyTypeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, occurDayNbInMonth=None, occurDayOrderInMonth=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.occurDayNbInMonth = occurDayNbInMonth
        self.occurDayOrderInMonth = occurDayOrderInMonth
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, monthlyTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if monthlyTypeType.subclass:
            return monthlyTypeType.subclass(*args_, **kwargs_)
        else:
            return monthlyTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_occurDayNbInMonth(self):
        return self.occurDayNbInMonth
    def set_occurDayNbInMonth(self, occurDayNbInMonth):
        self.occurDayNbInMonth = occurDayNbInMonth
    def get_occurDayOrderInMonth(self):
        return self.occurDayOrderInMonth
    def set_occurDayOrderInMonth(self, occurDayOrderInMonth):
        self.occurDayOrderInMonth = occurDayOrderInMonth
    def hasContent_(self):
        if (
            self.occurDayNbInMonth is not None or
            self.occurDayOrderInMonth is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='monthlyTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('monthlyTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='monthlyTypeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='monthlyTypeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='monthlyTypeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='monthlyTypeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.occurDayNbInMonth is not None:
            self.occurDayNbInMonth.export(outfile, level, namespaceprefix_, namespacedef_, name_='occurDayNbInMonth', pretty_print=pretty_print)
        if self.occurDayOrderInMonth is not None:
            self.occurDayOrderInMonth.export(outfile, level, namespaceprefix_, namespacedef_, name_='occurDayOrderInMonth', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'occurDayNbInMonth':
            obj_ = occurDayNbInMonthType.factory(parent_object_=self)
            obj_.build(child_)
            self.occurDayNbInMonth = obj_
            obj_.original_tagname_ = 'occurDayNbInMonth'
        elif nodeName_ == 'occurDayOrderInMonth':
            obj_ = occurDayOrderInMonthType.factory(parent_object_=self)
            obj_.build(child_)
            self.occurDayOrderInMonth = obj_
            obj_.original_tagname_ = 'occurDayOrderInMonth'
# end class monthlyTypeType


class occurDayNbInMonthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dayNb=None, everyNMonths=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.dayNb = dayNb
        self.everyNMonths = everyNMonths
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, occurDayNbInMonthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if occurDayNbInMonthType.subclass:
            return occurDayNbInMonthType.subclass(*args_, **kwargs_)
        else:
            return occurDayNbInMonthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayNb(self):
        return self.dayNb
    def set_dayNb(self, dayNb):
        self.dayNb = dayNb
    def get_everyNMonths(self):
        return self.everyNMonths
    def set_everyNMonths(self, everyNMonths):
        self.everyNMonths = everyNMonths
    def hasContent_(self):
        if (
            self.dayNb is not None or
            self.everyNMonths is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurDayNbInMonthType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('occurDayNbInMonthType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='occurDayNbInMonthType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='occurDayNbInMonthType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='occurDayNbInMonthType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurDayNbInMonthType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayNb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayNb>%s</%sdayNb>%s' % (namespaceprefix_ , self.gds_format_integer(self.dayNb, input_name='dayNb'), namespaceprefix_ , eol_))
        if self.everyNMonths is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyNMonths>%s</%severyNMonths>%s' % (namespaceprefix_ , self.gds_format_integer(self.everyNMonths, input_name='everyNMonths'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayNb' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'dayNb')
            self.dayNb = ival_
        elif nodeName_ == 'everyNMonths' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'everyNMonths')
            self.everyNMonths = ival_
# end class occurDayNbInMonthType


class occurDayOrderInMonthType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dayOrder=None, dayOfMonth=None, everyNMonths=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.dayOrder = dayOrder
        self.validate_dayOrderType(self.dayOrder)
        self.dayOfMonth = dayOfMonth
        self.validate_WeekDay(self.dayOfMonth)
        self.everyNMonths = everyNMonths
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, occurDayOrderInMonthType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if occurDayOrderInMonthType.subclass:
            return occurDayOrderInMonthType.subclass(*args_, **kwargs_)
        else:
            return occurDayOrderInMonthType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dayOrder(self):
        return self.dayOrder
    def set_dayOrder(self, dayOrder):
        self.dayOrder = dayOrder
    def get_dayOfMonth(self):
        return self.dayOfMonth
    def set_dayOfMonth(self, dayOfMonth):
        self.dayOfMonth = dayOfMonth
    def get_everyNMonths(self):
        return self.everyNMonths
    def set_everyNMonths(self, everyNMonths):
        self.everyNMonths = everyNMonths
    def validate_dayOrderType(self, value):
        # Validate type dayOrderType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['FIRST', 'SECOND', 'THIRD', 'FOURTH', 'LAST']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on dayOrderType' % {"value" : value.encode("utf-8")} )
    def validate_WeekDay(self, value):
        # Validate type WeekDay, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on WeekDay' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.dayOrder is not None or
            self.dayOfMonth is not None or
            self.everyNMonths is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurDayOrderInMonthType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('occurDayOrderInMonthType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='occurDayOrderInMonthType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='occurDayOrderInMonthType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='occurDayOrderInMonthType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='occurDayOrderInMonthType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dayOrder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOrder>%s</%sdayOrder>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dayOrder), input_name='dayOrder')), namespaceprefix_ , eol_))
        if self.dayOfMonth is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdayOfMonth>%s</%sdayOfMonth>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dayOfMonth), input_name='dayOfMonth')), namespaceprefix_ , eol_))
        if self.everyNMonths is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%severyNMonths>%s</%severyNMonths>%s' % (namespaceprefix_ , self.gds_format_integer(self.everyNMonths, input_name='everyNMonths'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dayOrder':
            dayOrder_ = child_.text
            dayOrder_ = self.gds_validate_string(dayOrder_, node, 'dayOrder')
            self.dayOrder = dayOrder_
            # validate type dayOrderType
            self.validate_dayOrderType(self.dayOrder)
        elif nodeName_ == 'dayOfMonth':
            dayOfMonth_ = child_.text
            dayOfMonth_ = self.gds_validate_string(dayOfMonth_, node, 'dayOfMonth')
            self.dayOfMonth = dayOfMonth_
            # validate type WeekDay
            self.validate_WeekDay(self.dayOfMonth)
        elif nodeName_ == 'everyNMonths' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'everyNMonths')
            self.everyNMonths = ival_
# end class occurDayOrderInMonthType


class listType38(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SeleniumScript=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if SeleniumScript is None:
            self.SeleniumScript = []
        else:
            self.SeleniumScript = SeleniumScript
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType38)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType38.subclass:
            return listType38.subclass(*args_, **kwargs_)
        else:
            return listType38(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeleniumScript(self):
        return self.SeleniumScript
    def set_SeleniumScript(self, SeleniumScript):
        self.SeleniumScript = SeleniumScript
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def insert_SeleniumScript_at(self, index, value):
        self.SeleniumScript.insert(index, value)
    def replace_SeleniumScript_at(self, index, value):
        self.SeleniumScript[index] = value
    def hasContent_(self):
        if (
            self.SeleniumScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType38', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType38')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType38')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType38', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType38'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType38', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SeleniumScript_ in self.SeleniumScript:
            SeleniumScript_.export(outfile, level, namespaceprefix_, name_='SeleniumScript', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.SeleniumScript.append(obj_)
            obj_.original_tagname_ = 'SeleniumScript'
# end class listType38


class setType39(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SeleniumScript=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if SeleniumScript is None:
            self.SeleniumScript = []
        else:
            self.SeleniumScript = SeleniumScript
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType39)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType39.subclass:
            return setType39.subclass(*args_, **kwargs_)
        else:
            return setType39(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeleniumScript(self):
        return self.SeleniumScript
    def set_SeleniumScript(self, SeleniumScript):
        self.SeleniumScript = SeleniumScript
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def insert_SeleniumScript_at(self, index, value):
        self.SeleniumScript.insert(index, value)
    def replace_SeleniumScript_at(self, index, value):
        self.SeleniumScript[index] = value
    def hasContent_(self):
        if (
            self.SeleniumScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType39', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType39')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType39')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType39', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType39'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType39', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SeleniumScript_ in self.SeleniumScript:
            SeleniumScript_.export(outfile, level, namespaceprefix_, name_='SeleniumScript', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.SeleniumScript.append(obj_)
            obj_.original_tagname_ = 'SeleniumScript'
# end class setType39


class addType40(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SeleniumScript=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if SeleniumScript is None:
            self.SeleniumScript = []
        else:
            self.SeleniumScript = SeleniumScript
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType40)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType40.subclass:
            return addType40.subclass(*args_, **kwargs_)
        else:
            return addType40(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeleniumScript(self):
        return self.SeleniumScript
    def set_SeleniumScript(self, SeleniumScript):
        self.SeleniumScript = SeleniumScript
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def insert_SeleniumScript_at(self, index, value):
        self.SeleniumScript.insert(index, value)
    def replace_SeleniumScript_at(self, index, value):
        self.SeleniumScript[index] = value
    def hasContent_(self):
        if (
            self.SeleniumScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType40', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType40')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType40')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType40', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType40'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType40', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SeleniumScript_ in self.SeleniumScript:
            SeleniumScript_.export(outfile, level, namespaceprefix_, name_='SeleniumScript', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.SeleniumScript.append(obj_)
            obj_.original_tagname_ = 'SeleniumScript'
# end class addType40


class removeType41(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SeleniumScript=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if SeleniumScript is None:
            self.SeleniumScript = []
        else:
            self.SeleniumScript = SeleniumScript
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType41)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType41.subclass:
            return removeType41.subclass(*args_, **kwargs_)
        else:
            return removeType41(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeleniumScript(self):
        return self.SeleniumScript
    def set_SeleniumScript(self, SeleniumScript):
        self.SeleniumScript = SeleniumScript
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def insert_SeleniumScript_at(self, index, value):
        self.SeleniumScript.insert(index, value)
    def replace_SeleniumScript_at(self, index, value):
        self.SeleniumScript[index] = value
    def hasContent_(self):
        if (
            self.SeleniumScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType41', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType41')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType41')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType41', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType41'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType41', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SeleniumScript_ in self.SeleniumScript:
            SeleniumScript_.export(outfile, level, namespaceprefix_, name_='SeleniumScript', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.SeleniumScript.append(obj_)
            obj_.original_tagname_ = 'SeleniumScript'
# end class removeType41


class updateType42(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SeleniumScript=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if SeleniumScript is None:
            self.SeleniumScript = []
        else:
            self.SeleniumScript = SeleniumScript
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType42)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType42.subclass:
            return updateType42.subclass(*args_, **kwargs_)
        else:
            return updateType42(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeleniumScript(self):
        return self.SeleniumScript
    def set_SeleniumScript(self, SeleniumScript):
        self.SeleniumScript = SeleniumScript
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def add_SeleniumScript(self, value):
        self.SeleniumScript.append(value)
    def insert_SeleniumScript_at(self, index, value):
        self.SeleniumScript.insert(index, value)
    def replace_SeleniumScript_at(self, index, value):
        self.SeleniumScript[index] = value
    def hasContent_(self):
        if (
            self.SeleniumScript
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType42', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType42')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType42')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType42', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType42'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType42', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SeleniumScript_ in self.SeleniumScript:
            SeleniumScript_.export(outfile, level, namespaceprefix_, name_='SeleniumScript', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.SeleniumScript.append(obj_)
            obj_.original_tagname_ = 'SeleniumScript'
# end class updateType42


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from webapp import *\n\n')
        sys.stdout.write('import webapp as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Attribute",
    "AttributeList",
    "Cdata",
    "Comment",
    "CommentList",
    "CrawlingScriptList",
    "Criteria",
    "DailyOccurrence",
    "DnsOverride",
    "DnsOverrideList",
    "Domain",
    "DomainList",
    "HourlyOccurrence",
    "HttpProxy",
    "MonthlyOccurrence",
    "ResponseErrorObject",
    "ScannerAppliance",
    "SchedulePlanification",
    "SeleniumScript",
    "ServiceRequest",
    "ServiceRequestData",
    "ServiceRequestFilters",
    "ServiceRequestPreferences",
    "ServiceResponse",
    "ServiceResponseData",
    "Tag",
    "TagList",
    "TimeZone",
    "Url",
    "UrlEntry",
    "UrlEntryList",
    "UrlList",
    "User",
    "WasScan",
    "WasScanOptionProfile",
    "WebApp",
    "WebAppAuthRecord",
    "WebAppAuthRecordList",
    "WebAppConfig",
    "WebAppHeader",
    "WebAppHeaderList",
    "WeeklyOccurrence",
    "addType",
    "addType13",
    "addType18",
    "addType22",
    "addType26",
    "addType3",
    "addType31",
    "addType36",
    "addType40",
    "addType8",
    "listType",
    "listType1",
    "listType11",
    "listType16",
    "listType20",
    "listType24",
    "listType29",
    "listType34",
    "listType38",
    "listType6",
    "monthlyTypeType",
    "occurDayNbInMonthType",
    "occurDayOrderInMonthType",
    "occurrenceType37",
    "onDaysType",
    "removeType",
    "removeType14",
    "removeType19",
    "removeType23",
    "removeType27",
    "removeType32",
    "removeType4",
    "removeType41",
    "removeType9",
    "setType",
    "setType12",
    "setType17",
    "setType2",
    "setType21",
    "setType25",
    "setType30",
    "setType35",
    "setType39",
    "setType7",
    "updateType",
    "updateType10",
    "updateType15",
    "updateType28",
    "updateType33",
    "updateType42",
    "updateType5"
]
