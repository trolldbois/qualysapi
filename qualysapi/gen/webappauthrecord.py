#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Dec 10 15:26:31 2018 by generateDS.py version 2.30.8.
# Python 3.6.1 (v3.6.1:69c0db5, Mar 21 2017, 18:41:36) [MSC v.1900 64 bit (AMD64)]
#
# Command line options:
#   ('-o', 'webappauthrecord.py')
#   ('-s', 'webappauthrecordsubs.py')
#   ('--super', 'qualysapi.gen.webappauthrecord')
#
# Command line arguments:
#   webappauthrecord.xsd
#
# Command line:
#   C:\Users\ljaqueme\DOCUME~1\02-THR~1\05-INT~1\10-IR-~1\V_IR-T~2\Scripts\generateDS -o "webappauthrecord.py" -s "webappauthrecordsubs.py" --super="qualysapi.gen.webappauthrecord" webappauthrecord.xsd
#
# Current working directory (os.getcwd()):
#   gen
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ResponseCode(object):
    AUTH_CREDENTIALS_NEEDED='AUTH_CREDENTIALS_NEEDED'
    CANNOT_BE_NULL='CANNOT_BE_NULL'
    INVALID_XML='INVALID_XML'
    INVALID_CREDENTIALS='INVALID_CREDENTIALS'
    INVALID_API_VERSION='INVALID_API_VERSION'
    INVALID_PARAM='INVALID_PARAM'
    INVALID_URL='INVALID_URL'
    INVALID_REQUEST='INVALID_REQUEST'
    NOT_FOUND='NOT_FOUND'
    OTHER_ERROR='OTHER_ERROR'
    OPERATION_NOT_SUPPORTED='OPERATION_NOT_SUPPORTED'
    EVALUATION_EXPIRED='EVALUATION_EXPIRED'
    JMS_SERVER_DOWN='JMS_SERVER_DOWN'
    RMI_SERVER_DOWN='RMI_SERVER_DOWN'
    SUCCESS='SUCCESS'
    STILL_PROCESSING='STILL_PROCESSING'
    UNAUTHORIZED='UNAUTHORIZED'
    UNAUTHORIZED_DESTINATION_APPS='UNAUTHORIZED_DESTINATION_APPS'
    UNIDENTIFIED_PRODUCER='UNIDENTIFIED_PRODUCER'
    UNKNOWN_OBJECT='UNKNOWN_OBJECT'


class typeType(object):
    STANDARD='STANDARD'
    CUSTOM='CUSTOM'
    SELENIUM='SELENIUM'


class typeType6(object):
    BASIC='BASIC'
    DIGEST='DIGEST'
    NTLM='NTLM'


class ServiceRequest(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, filters=None, preferences=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.filters = filters
        self.preferences = preferences
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequest.subclass:
            return ServiceRequest.subclass(*args_, **kwargs_)
        else:
            return ServiceRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filters(self):
        return self.filters
    def set_filters(self, filters):
        self.filters = filters
    def get_preferences(self):
        return self.preferences
    def set_preferences(self, preferences):
        self.preferences = preferences
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def hasContent_(self):
        if (
            self.filters is not None or
            self.preferences is not None or
            self.data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequest'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequest', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.filters is not None:
            self.filters.export(outfile, level, namespaceprefix_, name_='filters', pretty_print=pretty_print)
        if self.preferences is not None:
            self.preferences.export(outfile, level, namespaceprefix_, name_='preferences', pretty_print=pretty_print)
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'filters':
            obj_ = ServiceRequestFilters.factory(parent_object_=self)
            obj_.build(child_)
            self.filters = obj_
            obj_.original_tagname_ = 'filters'
        elif nodeName_ == 'preferences':
            obj_ = ServiceRequestPreferences.factory(parent_object_=self)
            obj_.build(child_)
            self.preferences = obj_
            obj_.original_tagname_ = 'preferences'
        elif nodeName_ == 'data':
            obj_ = ServiceRequestData.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
# end class ServiceRequest


class ServiceRequestFilters(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Criteria=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Criteria is None:
            self.Criteria = []
        else:
            self.Criteria = Criteria
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestFilters)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestFilters.subclass:
            return ServiceRequestFilters.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestFilters(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Criteria(self):
        return self.Criteria
    def set_Criteria(self, Criteria):
        self.Criteria = Criteria
    def add_Criteria(self, value):
        self.Criteria.append(value)
    def add_Criteria(self, value):
        self.Criteria.append(value)
    def insert_Criteria_at(self, index, value):
        self.Criteria.insert(index, value)
    def replace_Criteria_at(self, index, value):
        self.Criteria[index] = value
    def hasContent_(self):
        if (
            self.Criteria
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestFilters', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestFilters')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestFilters')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestFilters', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestFilters'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestFilters', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Criteria_ in self.Criteria:
            Criteria_.export(outfile, level, namespaceprefix_, name_='Criteria', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Criteria':
            obj_ = Criteria.factory(parent_object_=self)
            obj_.build(child_)
            self.Criteria.append(obj_)
            obj_.original_tagname_ = 'Criteria'
# end class ServiceRequestFilters


class Criteria(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, operator=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.field = _cast(None, field)
        self.operator = _cast(None, operator)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Criteria)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Criteria.subclass:
            return Criteria.subclass(*args_, **kwargs_)
        else:
            return Criteria(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self):
        return self.field
    def set_field(self, field):
        self.field = field
    def get_operator(self):
        return self.operator
    def set_operator(self, operator):
        self.operator = operator
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Criteria', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Criteria')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Criteria')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Criteria', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Criteria'):
        if self.field is not None and 'field' not in already_processed:
            already_processed.add('field')
            outfile.write(' field=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.field), input_name='field')), ))
        if self.operator is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            outfile.write(' operator=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.operator), input_name='operator')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Criteria', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('field', node)
        if value is not None and 'field' not in already_processed:
            already_processed.add('field')
            self.field = value
        value = find_attr_value_('operator', node)
        if value is not None and 'operator' not in already_processed:
            already_processed.add('operator')
            self.operator = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Criteria


class ServiceRequestPreferences(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, startFromId=None, startFromOffset=None, limitResults=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.startFromId = startFromId
        self.startFromOffset = startFromOffset
        self.limitResults = limitResults
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestPreferences)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestPreferences.subclass:
            return ServiceRequestPreferences.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestPreferences(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startFromId(self):
        return self.startFromId
    def set_startFromId(self, startFromId):
        self.startFromId = startFromId
    def get_startFromOffset(self):
        return self.startFromOffset
    def set_startFromOffset(self, startFromOffset):
        self.startFromOffset = startFromOffset
    def get_limitResults(self):
        return self.limitResults
    def set_limitResults(self, limitResults):
        self.limitResults = limitResults
    def hasContent_(self):
        if (
            self.startFromId is not None or
            self.startFromOffset is not None or
            self.limitResults is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestPreferences', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestPreferences')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestPreferences')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestPreferences', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestPreferences'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestPreferences', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.startFromId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartFromId>%s</%sstartFromId>%s' % (namespaceprefix_ , self.gds_format_integer(self.startFromId, input_name='startFromId'), namespaceprefix_ , eol_))
        if self.startFromOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartFromOffset>%s</%sstartFromOffset>%s' % (namespaceprefix_ , self.gds_format_integer(self.startFromOffset, input_name='startFromOffset'), namespaceprefix_ , eol_))
        if self.limitResults is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimitResults>%s</%slimitResults>%s' % (namespaceprefix_ , self.gds_format_integer(self.limitResults, input_name='limitResults'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'startFromId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startFromId')
            self.startFromId = ival_
        elif nodeName_ == 'startFromOffset' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startFromOffset')
            self.startFromOffset = ival_
        elif nodeName_ == 'limitResults' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limitResults')
            self.limitResults = ival_
# end class ServiceRequestPreferences


class ServiceRequestData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceRequestData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceRequestData.subclass:
            return ServiceRequestData.subclass(*args_, **kwargs_)
        else:
            return ServiceRequestData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def hasContent_(self):
        if (
            self.WebAppAuthRecord is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceRequestData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceRequestData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceRequestData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceRequestData'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceRequestData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.WebAppAuthRecord is not None:
            self.WebAppAuthRecord.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord = obj_
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class ServiceRequestData


class ServiceResponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, responseCode=None, responseErrorDetails=None, count=None, hasMoreRecords=None, lastId=None, data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.responseCode = responseCode
        self.validate_ResponseCode(self.responseCode)
        self.responseErrorDetails = responseErrorDetails
        self.count = count
        self.hasMoreRecords = hasMoreRecords
        self.lastId = lastId
        self.data = data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceResponse.subclass:
            return ServiceResponse.subclass(*args_, **kwargs_)
        else:
            return ServiceResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_responseCode(self):
        return self.responseCode
    def set_responseCode(self, responseCode):
        self.responseCode = responseCode
    def get_responseErrorDetails(self):
        return self.responseErrorDetails
    def set_responseErrorDetails(self, responseErrorDetails):
        self.responseErrorDetails = responseErrorDetails
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_hasMoreRecords(self):
        return self.hasMoreRecords
    def set_hasMoreRecords(self, hasMoreRecords):
        self.hasMoreRecords = hasMoreRecords
    def get_lastId(self):
        return self.lastId
    def set_lastId(self, lastId):
        self.lastId = lastId
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def validate_ResponseCode(self, value):
        # Validate type ResponseCode, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AUTH_CREDENTIALS_NEEDED', 'CANNOT_BE_NULL', 'INVALID_XML', 'INVALID_CREDENTIALS', 'INVALID_API_VERSION', 'INVALID_PARAM', 'INVALID_URL', 'INVALID_REQUEST', 'NOT_FOUND', 'OTHER_ERROR', 'OPERATION_NOT_SUPPORTED', 'EVALUATION_EXPIRED', 'JMS_SERVER_DOWN', 'RMI_SERVER_DOWN', 'SUCCESS', 'STILL_PROCESSING', 'UNAUTHORIZED', 'UNAUTHORIZED_DESTINATION_APPS', 'UNIDENTIFIED_PRODUCER', 'UNKNOWN_OBJECT']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on ResponseCode' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.responseCode is not None or
            self.responseErrorDetails is not None or
            self.count is not None or
            self.hasMoreRecords is not None or
            self.lastId is not None or
            self.data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceResponse'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponse', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.responseCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sresponseCode>%s</%sresponseCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.responseCode), input_name='responseCode')), namespaceprefix_ , eol_))
        if self.responseErrorDetails is not None:
            self.responseErrorDetails.export(outfile, level, namespaceprefix_, name_='responseErrorDetails', pretty_print=pretty_print)
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.hasMoreRecords is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%shasMoreRecords>%s</%shasMoreRecords>%s' % (namespaceprefix_ , self.gds_format_boolean(self.hasMoreRecords, input_name='hasMoreRecords'), namespaceprefix_ , eol_))
        if self.lastId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastId>%s</%slastId>%s' % (namespaceprefix_ , self.gds_format_integer(self.lastId, input_name='lastId'), namespaceprefix_ , eol_))
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'responseCode':
            responseCode_ = child_.text
            responseCode_ = self.gds_validate_string(responseCode_, node, 'responseCode')
            self.responseCode = responseCode_
            # validate type ResponseCode
            self.validate_ResponseCode(self.responseCode)
        elif nodeName_ == 'responseErrorDetails':
            obj_ = ResponseErrorObject.factory(parent_object_=self)
            obj_.build(child_)
            self.responseErrorDetails = obj_
            obj_.original_tagname_ = 'responseErrorDetails'
        elif nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'hasMoreRecords':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'hasMoreRecords')
            self.hasMoreRecords = ival_
        elif nodeName_ == 'lastId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastId')
            self.lastId = ival_
        elif nodeName_ == 'data':
            obj_ = ServiceResponseData.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
# end class ServiceResponse


class ResponseErrorObject(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, errorMessage=None, errorResolution=None, internalErrorCodeId=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.errorMessage = errorMessage
        self.errorResolution = errorResolution
        self.internalErrorCodeId = internalErrorCodeId
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseErrorObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseErrorObject.subclass:
            return ResponseErrorObject.subclass(*args_, **kwargs_)
        else:
            return ResponseErrorObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_errorMessage(self):
        return self.errorMessage
    def set_errorMessage(self, errorMessage):
        self.errorMessage = errorMessage
    def get_errorResolution(self):
        return self.errorResolution
    def set_errorResolution(self, errorResolution):
        self.errorResolution = errorResolution
    def get_internalErrorCodeId(self):
        return self.internalErrorCodeId
    def set_internalErrorCodeId(self, internalErrorCodeId):
        self.internalErrorCodeId = internalErrorCodeId
    def hasContent_(self):
        if (
            self.errorMessage is not None or
            self.errorResolution is not None or
            self.internalErrorCodeId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseErrorObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseErrorObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseErrorObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseErrorObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseErrorObject'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseErrorObject', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.errorMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorMessage>%s</%serrorMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorMessage), input_name='errorMessage')), namespaceprefix_ , eol_))
        if self.errorResolution is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%serrorResolution>%s</%serrorResolution>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.errorResolution), input_name='errorResolution')), namespaceprefix_ , eol_))
        if self.internalErrorCodeId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinternalErrorCodeId>%s</%sinternalErrorCodeId>%s' % (namespaceprefix_ , self.gds_format_integer(self.internalErrorCodeId, input_name='internalErrorCodeId'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'errorMessage':
            errorMessage_ = child_.text
            errorMessage_ = self.gds_validate_string(errorMessage_, node, 'errorMessage')
            self.errorMessage = errorMessage_
        elif nodeName_ == 'errorResolution':
            errorResolution_ = child_.text
            errorResolution_ = self.gds_validate_string(errorResolution_, node, 'errorResolution')
            self.errorResolution = errorResolution_
        elif nodeName_ == 'internalErrorCodeId' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'internalErrorCodeId')
            self.internalErrorCodeId = ival_
# end class ResponseErrorObject


class ServiceResponseData(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthRecord=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthRecord is None:
            self.WebAppAuthRecord = []
        else:
            self.WebAppAuthRecord = WebAppAuthRecord
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceResponseData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceResponseData.subclass:
            return ServiceResponseData.subclass(*args_, **kwargs_)
        else:
            return ServiceResponseData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthRecord(self):
        return self.WebAppAuthRecord
    def set_WebAppAuthRecord(self, WebAppAuthRecord):
        self.WebAppAuthRecord = WebAppAuthRecord
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def add_WebAppAuthRecord(self, value):
        self.WebAppAuthRecord.append(value)
    def insert_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord.insert(index, value)
    def replace_WebAppAuthRecord_at(self, index, value):
        self.WebAppAuthRecord[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthRecord
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponseData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceResponseData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceResponseData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceResponseData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceResponseData'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceResponseData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthRecord_ in self.WebAppAuthRecord:
            WebAppAuthRecord_.export(outfile, level, namespaceprefix_, name_='WebAppAuthRecord', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthRecord':
            obj_ = WebAppAuthRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthRecord.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthRecord'
# end class ServiceResponseData


class WebAppAuthRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, owner=None, formRecord=None, serverRecord=None, tags=None, comments=None, createdDate=None, createdBy=None, updatedDate=None, updatedBy=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
        self.owner = owner
        self.formRecord = formRecord
        self.serverRecord = serverRecord
        self.tags = tags
        self.comments = comments
        if isinstance(createdDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createdDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createdDate
        self.createdDate = initvalue_
        self.createdBy = createdBy
        if isinstance(updatedDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(updatedDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = updatedDate
        self.updatedDate = initvalue_
        self.updatedBy = updatedBy
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthRecord.subclass:
            return WebAppAuthRecord.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_owner(self):
        return self.owner
    def set_owner(self, owner):
        self.owner = owner
    def get_formRecord(self):
        return self.formRecord
    def set_formRecord(self, formRecord):
        self.formRecord = formRecord
    def get_serverRecord(self):
        return self.serverRecord
    def set_serverRecord(self, serverRecord):
        self.serverRecord = serverRecord
    def get_tags(self):
        return self.tags
    def set_tags(self, tags):
        self.tags = tags
    def get_comments(self):
        return self.comments
    def set_comments(self, comments):
        self.comments = comments
    def get_createdDate(self):
        return self.createdDate
    def set_createdDate(self, createdDate):
        self.createdDate = createdDate
    def get_createdBy(self):
        return self.createdBy
    def set_createdBy(self, createdBy):
        self.createdBy = createdBy
    def get_updatedDate(self):
        return self.updatedDate
    def set_updatedDate(self, updatedDate):
        self.updatedDate = updatedDate
    def get_updatedBy(self):
        return self.updatedBy
    def set_updatedBy(self, updatedBy):
        self.updatedBy = updatedBy
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.owner is not None or
            self.formRecord is not None or
            self.serverRecord is not None or
            self.tags is not None or
            self.comments is not None or
            self.createdDate is not None or
            self.createdBy is not None or
            self.updatedDate is not None or
            self.updatedBy is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecord', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthRecord'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.owner is not None:
            self.owner.export(outfile, level, namespaceprefix_, name_='owner', pretty_print=pretty_print)
        if self.formRecord is not None:
            self.formRecord.export(outfile, level, namespaceprefix_, name_='formRecord', pretty_print=pretty_print)
        if self.serverRecord is not None:
            self.serverRecord.export(outfile, level, namespaceprefix_, name_='serverRecord', pretty_print=pretty_print)
        if self.tags is not None:
            self.tags.export(outfile, level, namespaceprefix_, name_='tags', pretty_print=pretty_print)
        if self.comments is not None:
            self.comments.export(outfile, level, namespaceprefix_, name_='comments', pretty_print=pretty_print)
        if self.createdDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.createdDate, input_name='createdDate'), namespaceprefix_ , eol_))
        if self.createdBy is not None:
            self.createdBy.export(outfile, level, namespaceprefix_, name_='createdBy', pretty_print=pretty_print)
        if self.updatedDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supdatedDate>%s</%supdatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.updatedDate, input_name='updatedDate'), namespaceprefix_ , eol_))
        if self.updatedBy is not None:
            self.updatedBy.export(outfile, level, namespaceprefix_, name_='updatedBy', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'owner':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.owner = obj_
            obj_.original_tagname_ = 'owner'
        elif nodeName_ == 'formRecord':
            obj_ = WebAppAuthFormRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.formRecord = obj_
            obj_.original_tagname_ = 'formRecord'
        elif nodeName_ == 'serverRecord':
            obj_ = WebAppAuthServerRecord.factory(parent_object_=self)
            obj_.build(child_)
            self.serverRecord = obj_
            obj_.original_tagname_ = 'serverRecord'
        elif nodeName_ == 'tags':
            obj_ = TagList.factory(parent_object_=self)
            obj_.build(child_)
            self.tags = obj_
            obj_.original_tagname_ = 'tags'
        elif nodeName_ == 'comments':
            obj_ = CommentList.factory(parent_object_=self)
            obj_.build(child_)
            self.comments = obj_
            obj_.original_tagname_ = 'comments'
        elif nodeName_ == 'createdDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createdDate = dval_
        elif nodeName_ == 'createdBy':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.createdBy = obj_
            obj_.original_tagname_ = 'createdBy'
        elif nodeName_ == 'updatedDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.updatedDate = dval_
        elif nodeName_ == 'updatedBy':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.updatedBy = obj_
            obj_.original_tagname_ = 'updatedBy'
# end class WebAppAuthRecord


class WebAppAuthFormRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, sslOnly=None, seleniumScript=None, fields=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.type_ = type_
        self.validate_typeType(self.type_)
        self.sslOnly = sslOnly
        self.seleniumScript = seleniumScript
        self.fields = fields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthFormRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthFormRecord.subclass:
            return WebAppAuthFormRecord.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthFormRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_sslOnly(self):
        return self.sslOnly
    def set_sslOnly(self, sslOnly):
        self.sslOnly = sslOnly
    def get_seleniumScript(self):
        return self.seleniumScript
    def set_seleniumScript(self, seleniumScript):
        self.seleniumScript = seleniumScript
    def get_fields(self):
        return self.fields
    def set_fields(self, fields):
        self.fields = fields
    def validate_typeType(self, value):
        # Validate type typeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['STANDARD', 'CUSTOM', 'SELENIUM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.sslOnly is not None or
            self.seleniumScript is not None or
            self.fields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecord', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthFormRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthFormRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthFormRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthFormRecord'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.sslOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssslOnly>%s</%ssslOnly>%s' % (namespaceprefix_ , self.gds_format_boolean(self.sslOnly, input_name='sslOnly'), namespaceprefix_ , eol_))
        if self.seleniumScript is not None:
            self.seleniumScript.export(outfile, level, namespaceprefix_, name_='seleniumScript', pretty_print=pretty_print)
        if self.fields is not None:
            self.fields.export(outfile, level, namespaceprefix_, name_='fields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type typeType
            self.validate_typeType(self.type_)
        elif nodeName_ == 'sslOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sslOnly')
            self.sslOnly = ival_
        elif nodeName_ == 'seleniumScript':
            obj_ = SeleniumScript.factory(parent_object_=self)
            obj_.build(child_)
            self.seleniumScript = obj_
            obj_.original_tagname_ = 'seleniumScript'
        elif nodeName_ == 'fields':
            obj_ = WebAppAuthFormRecordFieldList.factory(parent_object_=self)
            obj_.build(child_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
# end class WebAppAuthFormRecord


class WebAppAuthFormRecordFieldList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthFormRecordFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthFormRecordFieldList.subclass:
            return WebAppAuthFormRecordFieldList.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthFormRecordFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecordFieldList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthFormRecordFieldList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthFormRecordFieldList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthFormRecordFieldList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthFormRecordFieldList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecordFieldList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class WebAppAuthFormRecordFieldList


class WebAppAuthFormRecordField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, secured=None, value=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
        self.secured = secured
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthFormRecordField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthFormRecordField.subclass:
            return WebAppAuthFormRecordField.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthFormRecordField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_secured(self):
        return self.secured
    def set_secured(self, secured):
        self.secured = secured
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None or
            self.secured is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecordField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthFormRecordField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthFormRecordField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthFormRecordField'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthFormRecordField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.secured is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssecured>%s</%ssecured>%s' % (namespaceprefix_ , self.gds_format_boolean(self.secured, input_name='secured'), namespaceprefix_ , eol_))
        if self.value is not None:
            self.value.export(outfile, level, namespaceprefix_, name_='value', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'secured':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'secured')
            self.secured = ival_
        elif nodeName_ == 'value':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class WebAppAuthFormRecordField


class SeleniumScript(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, data=None, regex=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.data = data
        self.regex = regex
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SeleniumScript)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SeleniumScript.subclass:
            return SeleniumScript.subclass(*args_, **kwargs_)
        else:
            return SeleniumScript(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_data(self):
        return self.data
    def set_data(self, data):
        self.data = data
    def get_regex(self):
        return self.regex
    def set_regex(self, regex):
        self.regex = regex
    def hasContent_(self):
        if (
            self.name is not None or
            self.data is not None or
            self.regex is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeleniumScript', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SeleniumScript')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SeleniumScript')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SeleniumScript', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SeleniumScript'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SeleniumScript', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.data is not None:
            self.data.export(outfile, level, namespaceprefix_, name_='data', pretty_print=pretty_print)
        if self.regex is not None:
            self.regex.export(outfile, level, namespaceprefix_, name_='regex', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'data':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.data = obj_
            obj_.original_tagname_ = 'data'
        elif nodeName_ == 'regex':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.regex = obj_
            obj_.original_tagname_ = 'regex'
# end class SeleniumScript


class WebAppAuthServerRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sslOnly=None, certificate=None, fields=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.sslOnly = sslOnly
        self.certificate = certificate
        self.fields = fields
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthServerRecord)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthServerRecord.subclass:
            return WebAppAuthServerRecord.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthServerRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sslOnly(self):
        return self.sslOnly
    def set_sslOnly(self, sslOnly):
        self.sslOnly = sslOnly
    def get_certificate(self):
        return self.certificate
    def set_certificate(self, certificate):
        self.certificate = certificate
    def get_fields(self):
        return self.fields
    def set_fields(self, fields):
        self.fields = fields
    def hasContent_(self):
        if (
            self.sslOnly is not None or
            self.certificate is not None or
            self.fields is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecord', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthServerRecord')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthServerRecord')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthServerRecord', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthServerRecord'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecord', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sslOnly is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssslOnly>%s</%ssslOnly>%s' % (namespaceprefix_ , self.gds_format_boolean(self.sslOnly, input_name='sslOnly'), namespaceprefix_ , eol_))
        if self.certificate is not None:
            self.certificate.export(outfile, level, namespaceprefix_, name_='certificate', pretty_print=pretty_print)
        if self.fields is not None:
            self.fields.export(outfile, level, namespaceprefix_, name_='fields', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'sslOnly':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'sslOnly')
            self.sslOnly = ival_
        elif nodeName_ == 'certificate':
            obj_ = Certificate.factory(parent_object_=self)
            obj_.build(child_)
            self.certificate = obj_
            obj_.original_tagname_ = 'certificate'
        elif nodeName_ == 'fields':
            obj_ = WebAppAuthServerRecordFieldList.factory(parent_object_=self)
            obj_.build(child_)
            self.fields = obj_
            obj_.original_tagname_ = 'fields'
# end class WebAppAuthServerRecord


class WebAppAuthServerRecordFieldList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, update=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
        self.update = update
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthServerRecordFieldList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthServerRecordFieldList.subclass:
            return WebAppAuthServerRecordFieldList.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthServerRecordFieldList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def get_update(self):
        return self.update
    def set_update(self, update):
        self.update = update
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None or
            self.update is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecordFieldList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthServerRecordFieldList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthServerRecordFieldList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthServerRecordFieldList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthServerRecordFieldList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecordFieldList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
        if self.update is not None:
            self.update.export(outfile, level, namespaceprefix_, name_='update', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType1.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType2.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType3.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType4.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
        elif nodeName_ == 'update':
            obj_ = updateType5.factory(parent_object_=self)
            obj_.build(child_)
            self.update = obj_
            obj_.original_tagname_ = 'update'
# end class WebAppAuthServerRecordFieldList


class WebAppAuthServerRecordField(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, type_=None, domain=None, username=None, password=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.type_ = type_
        self.validate_typeType6(self.type_)
        self.domain = domain
        self.username = username
        self.password = password
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WebAppAuthServerRecordField)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WebAppAuthServerRecordField.subclass:
            return WebAppAuthServerRecordField.subclass(*args_, **kwargs_)
        else:
            return WebAppAuthServerRecordField(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_domain(self):
        return self.domain
    def set_domain(self, domain):
        self.domain = domain
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    def get_password(self):
        return self.password
    def set_password(self, password):
        self.password = password
    def validate_typeType6(self, value):
        # Validate type typeType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BASIC', 'DIGEST', 'NTLM']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeType6' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.id is not None or
            self.type_ is not None or
            self.domain is not None or
            self.username is not None or
            self.password is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecordField', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WebAppAuthServerRecordField')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WebAppAuthServerRecordField')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WebAppAuthServerRecordField'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='WebAppAuthServerRecordField', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
        if self.domain is not None:
            self.domain.export(outfile, level, namespaceprefix_, name_='domain', pretty_print=pretty_print)
        if self.username is not None:
            self.username.export(outfile, level, namespaceprefix_, name_='username', pretty_print=pretty_print)
        if self.password is not None:
            self.password.export(outfile, level, namespaceprefix_, name_='password', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            # validate type typeType6
            self.validate_typeType6(self.type_)
        elif nodeName_ == 'domain':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.domain = obj_
            obj_.original_tagname_ = 'domain'
        elif nodeName_ == 'username':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.username = obj_
            obj_.original_tagname_ = 'username'
        elif nodeName_ == 'password':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.password = obj_
            obj_.original_tagname_ = 'password'
# end class WebAppAuthServerRecordField


class Certificate(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, contents=None, passphrase=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.name = name
        self.contents = contents
        self.passphrase = passphrase
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Certificate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Certificate.subclass:
            return Certificate.subclass(*args_, **kwargs_)
        else:
            return Certificate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def get_contents(self):
        return self.contents
    def set_contents(self, contents):
        self.contents = contents
    def get_passphrase(self):
        return self.passphrase
    def set_passphrase(self, passphrase):
        self.passphrase = passphrase
    def hasContent_(self):
        if (
            self.name is not None or
            self.contents is not None or
            self.passphrase is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Certificate', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Certificate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Certificate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Certificate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Certificate'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Certificate', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
        if self.contents is not None:
            self.contents.export(outfile, level, namespaceprefix_, name_='contents', pretty_print=pretty_print)
        if self.passphrase is not None:
            self.passphrase.export(outfile, level, namespaceprefix_, name_='passphrase', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
        elif nodeName_ == 'contents':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.contents = obj_
            obj_.original_tagname_ = 'contents'
        elif nodeName_ == 'passphrase':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.passphrase = obj_
            obj_.original_tagname_ = 'passphrase'
# end class Certificate


class TagList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, remove=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
        self.remove = remove
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TagList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TagList.subclass:
            return TagList.subclass(*args_, **kwargs_)
        else:
            return TagList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def get_remove(self):
        return self.remove
    def set_remove(self, remove):
        self.remove = remove
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None or
            self.remove is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TagList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TagList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TagList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TagList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TagList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
        if self.remove is not None:
            self.remove.export(outfile, level, namespaceprefix_, name_='remove', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType7.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType8.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType9.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
        elif nodeName_ == 'remove':
            obj_ = removeType10.factory(parent_object_=self)
            obj_.build(child_)
            self.remove = obj_
            obj_.original_tagname_ = 'remove'
# end class TagList


class Tag(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, name=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.name = name
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Tag)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Tag.subclass:
            return Tag.subclass(*args_, **kwargs_)
        else:
            return Tag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_name(self):
        return self.name
    def set_name(self, name):
        self.name = name
    def hasContent_(self):
        if (
            self.id is not None or
            self.name is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Tag', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Tag')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Tag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Tag', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Tag'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Tag', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.name is not None:
            self.name.export(outfile, level, namespaceprefix_, name_='name', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'name':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.name = obj_
            obj_.original_tagname_ = 'name'
# end class Tag


class CommentList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, list=None, set=None, add=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.count = count
        self.list = list
        self.set = set
        self.add = add
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommentList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommentList.subclass:
            return CommentList.subclass(*args_, **kwargs_)
        else:
            return CommentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_count(self):
        return self.count
    def set_count(self, count):
        self.count = count
    def get_list(self):
        return self.list
    def set_list(self, list):
        self.list = list
    def get_set(self):
        return self.set
    def set_set(self, set):
        self.set = set
    def get_add(self):
        return self.add
    def set_add(self, add):
        self.add = add
    def hasContent_(self):
        if (
            self.count is not None or
            self.list is not None or
            self.set is not None or
            self.add is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommentList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommentList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommentList'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommentList', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scount>%s</%scount>%s' % (namespaceprefix_ , self.gds_format_integer(self.count, input_name='count'), namespaceprefix_ , eol_))
        if self.list is not None:
            self.list.export(outfile, level, namespaceprefix_, name_='list', pretty_print=pretty_print)
        if self.set is not None:
            self.set.export(outfile, level, namespaceprefix_, name_='set', pretty_print=pretty_print)
        if self.add is not None:
            self.add.export(outfile, level, namespaceprefix_, name_='add', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'count' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'count')
            self.count = ival_
        elif nodeName_ == 'list':
            obj_ = listType11.factory(parent_object_=self)
            obj_.build(child_)
            self.list = obj_
            obj_.original_tagname_ = 'list'
        elif nodeName_ == 'set':
            obj_ = setType12.factory(parent_object_=self)
            obj_.build(child_)
            self.set = obj_
            obj_.original_tagname_ = 'set'
        elif nodeName_ == 'add':
            obj_ = addType13.factory(parent_object_=self)
            obj_.build(child_)
            self.add = obj_
            obj_.original_tagname_ = 'add'
# end class CommentList


class Comment(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, contents=None, author=None, createdDate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.contents = contents
        self.author = author
        if isinstance(createdDate, BaseStrType_):
            initvalue_ = datetime_.datetime.strptime(createdDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = createdDate
        self.createdDate = initvalue_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Comment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Comment.subclass:
            return Comment.subclass(*args_, **kwargs_)
        else:
            return Comment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contents(self):
        return self.contents
    def set_contents(self, contents):
        self.contents = contents
    def get_author(self):
        return self.author
    def set_author(self, author):
        self.author = author
    def get_createdDate(self):
        return self.createdDate
    def set_createdDate(self, createdDate):
        self.createdDate = createdDate
    def hasContent_(self):
        if (
            self.contents is not None or
            self.author is not None or
            self.createdDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Comment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Comment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Comment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Comment'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Comment', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.contents is not None:
            self.contents.export(outfile, level, namespaceprefix_, namespacedef_, name_='contents', pretty_print=pretty_print)
        if self.author is not None:
            self.author.export(outfile, level, namespaceprefix_, name_='author', pretty_print=pretty_print)
        if self.createdDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%screatedDate>%s</%screatedDate>%s' % (namespaceprefix_ , self.gds_format_datetime(self.createdDate, input_name='createdDate'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'contents':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.contents = obj_
            obj_.original_tagname_ = 'contents'
        elif nodeName_ == 'author':
            obj_ = User.factory(parent_object_=self)
            obj_.build(child_)
            self.author = obj_
            obj_.original_tagname_ = 'author'
        elif nodeName_ == 'createdDate':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.createdDate = dval_
# end class Comment


class Cdata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Cdata)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Cdata.subclass:
            return Cdata.subclass(*args_, **kwargs_)
        else:
            return Cdata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cdata', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Cdata')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Cdata')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Cdata', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Cdata'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Cdata', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Cdata


class User(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, username=None, firstName=None, lastName=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.id = id
        self.username = username
        self.firstName = firstName
        self.lastName = lastName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, User)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if User.subclass:
            return User.subclass(*args_, **kwargs_)
        else:
            return User(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_username(self):
        return self.username
    def set_username(self, username):
        self.username = username
    def get_firstName(self):
        return self.firstName
    def set_firstName(self, firstName):
        self.firstName = firstName
    def get_lastName(self):
        return self.lastName
    def set_lastName(self, lastName):
        self.lastName = lastName
    def hasContent_(self):
        if (
            self.id is not None or
            self.username is not None or
            self.firstName is not None or
            self.lastName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='User', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('User')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='User')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='User', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='User'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='User', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sid>%s</%sid>%s' % (namespaceprefix_ , self.gds_format_integer(self.id, input_name='id'), namespaceprefix_ , eol_))
        if self.username is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%susername>%s</%susername>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.username), input_name='username')), namespaceprefix_ , eol_))
        if self.firstName is not None:
            self.firstName.export(outfile, level, namespaceprefix_, name_='firstName', pretty_print=pretty_print)
        if self.lastName is not None:
            self.lastName.export(outfile, level, namespaceprefix_, name_='lastName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'id' and child_.text:
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'id')
            self.id = ival_
        elif nodeName_ == 'username':
            username_ = child_.text
            username_ = self.gds_validate_string(username_, node, 'username')
            self.username = username_
        elif nodeName_ == 'firstName':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.firstName = obj_
            obj_.original_tagname_ = 'firstName'
        elif nodeName_ == 'lastName':
            obj_ = Cdata.factory(parent_object_=self)
            obj_.build(child_)
            self.lastName = obj_
            obj_.original_tagname_ = 'lastName'
# end class User


class listType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthFormRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthFormRecordField is None:
            self.WebAppAuthFormRecordField = []
        else:
            self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType.subclass:
            return listType.subclass(*args_, **kwargs_)
        else:
            return listType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthFormRecordField(self):
        return self.WebAppAuthFormRecordField
    def set_WebAppAuthFormRecordField(self, WebAppAuthFormRecordField):
        self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def insert_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField.insert(index, value)
    def replace_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthFormRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthFormRecordField_ in self.WebAppAuthFormRecordField:
            WebAppAuthFormRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthFormRecordField':
            obj_ = WebAppAuthFormRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthFormRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthFormRecordField'
# end class listType


class setType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthFormRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthFormRecordField is None:
            self.WebAppAuthFormRecordField = []
        else:
            self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType.subclass:
            return setType.subclass(*args_, **kwargs_)
        else:
            return setType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthFormRecordField(self):
        return self.WebAppAuthFormRecordField
    def set_WebAppAuthFormRecordField(self, WebAppAuthFormRecordField):
        self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def insert_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField.insert(index, value)
    def replace_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthFormRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthFormRecordField_ in self.WebAppAuthFormRecordField:
            WebAppAuthFormRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthFormRecordField':
            obj_ = WebAppAuthFormRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthFormRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthFormRecordField'
# end class setType


class addType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthFormRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthFormRecordField is None:
            self.WebAppAuthFormRecordField = []
        else:
            self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType.subclass:
            return addType.subclass(*args_, **kwargs_)
        else:
            return addType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthFormRecordField(self):
        return self.WebAppAuthFormRecordField
    def set_WebAppAuthFormRecordField(self, WebAppAuthFormRecordField):
        self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def insert_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField.insert(index, value)
    def replace_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthFormRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthFormRecordField_ in self.WebAppAuthFormRecordField:
            WebAppAuthFormRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthFormRecordField':
            obj_ = WebAppAuthFormRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthFormRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthFormRecordField'
# end class addType


class removeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthFormRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthFormRecordField is None:
            self.WebAppAuthFormRecordField = []
        else:
            self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType.subclass:
            return removeType.subclass(*args_, **kwargs_)
        else:
            return removeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthFormRecordField(self):
        return self.WebAppAuthFormRecordField
    def set_WebAppAuthFormRecordField(self, WebAppAuthFormRecordField):
        self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def insert_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField.insert(index, value)
    def replace_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthFormRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthFormRecordField_ in self.WebAppAuthFormRecordField:
            WebAppAuthFormRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthFormRecordField':
            obj_ = WebAppAuthFormRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthFormRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthFormRecordField'
# end class removeType


class updateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthFormRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthFormRecordField is None:
            self.WebAppAuthFormRecordField = []
        else:
            self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType.subclass:
            return updateType.subclass(*args_, **kwargs_)
        else:
            return updateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthFormRecordField(self):
        return self.WebAppAuthFormRecordField
    def set_WebAppAuthFormRecordField(self, WebAppAuthFormRecordField):
        self.WebAppAuthFormRecordField = WebAppAuthFormRecordField
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def add_WebAppAuthFormRecordField(self, value):
        self.WebAppAuthFormRecordField.append(value)
    def insert_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField.insert(index, value)
    def replace_WebAppAuthFormRecordField_at(self, index, value):
        self.WebAppAuthFormRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthFormRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthFormRecordField_ in self.WebAppAuthFormRecordField:
            WebAppAuthFormRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthFormRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthFormRecordField':
            obj_ = WebAppAuthFormRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthFormRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthFormRecordField'
# end class updateType


class listType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthServerRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthServerRecordField is None:
            self.WebAppAuthServerRecordField = []
        else:
            self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType1)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType1.subclass:
            return listType1.subclass(*args_, **kwargs_)
        else:
            return listType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthServerRecordField(self):
        return self.WebAppAuthServerRecordField
    def set_WebAppAuthServerRecordField(self, WebAppAuthServerRecordField):
        self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def insert_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField.insert(index, value)
    def replace_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthServerRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType1', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType1')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType1'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthServerRecordField_ in self.WebAppAuthServerRecordField:
            WebAppAuthServerRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthServerRecordField':
            obj_ = WebAppAuthServerRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthServerRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthServerRecordField'
# end class listType1


class setType2(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthServerRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthServerRecordField is None:
            self.WebAppAuthServerRecordField = []
        else:
            self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType2)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType2.subclass:
            return setType2.subclass(*args_, **kwargs_)
        else:
            return setType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthServerRecordField(self):
        return self.WebAppAuthServerRecordField
    def set_WebAppAuthServerRecordField(self, WebAppAuthServerRecordField):
        self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def insert_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField.insert(index, value)
    def replace_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthServerRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType2', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType2')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType2', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType2'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType2', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthServerRecordField_ in self.WebAppAuthServerRecordField:
            WebAppAuthServerRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthServerRecordField':
            obj_ = WebAppAuthServerRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthServerRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthServerRecordField'
# end class setType2


class addType3(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthServerRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthServerRecordField is None:
            self.WebAppAuthServerRecordField = []
        else:
            self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType3)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType3.subclass:
            return addType3.subclass(*args_, **kwargs_)
        else:
            return addType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthServerRecordField(self):
        return self.WebAppAuthServerRecordField
    def set_WebAppAuthServerRecordField(self, WebAppAuthServerRecordField):
        self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def insert_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField.insert(index, value)
    def replace_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthServerRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType3', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType3')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType3', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType3'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType3', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthServerRecordField_ in self.WebAppAuthServerRecordField:
            WebAppAuthServerRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthServerRecordField':
            obj_ = WebAppAuthServerRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthServerRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthServerRecordField'
# end class addType3


class removeType4(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthServerRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthServerRecordField is None:
            self.WebAppAuthServerRecordField = []
        else:
            self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType4.subclass:
            return removeType4.subclass(*args_, **kwargs_)
        else:
            return removeType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthServerRecordField(self):
        return self.WebAppAuthServerRecordField
    def set_WebAppAuthServerRecordField(self, WebAppAuthServerRecordField):
        self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def insert_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField.insert(index, value)
    def replace_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthServerRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType4'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthServerRecordField_ in self.WebAppAuthServerRecordField:
            WebAppAuthServerRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthServerRecordField':
            obj_ = WebAppAuthServerRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthServerRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthServerRecordField'
# end class removeType4


class updateType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, WebAppAuthServerRecordField=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if WebAppAuthServerRecordField is None:
            self.WebAppAuthServerRecordField = []
        else:
            self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, updateType5)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if updateType5.subclass:
            return updateType5.subclass(*args_, **kwargs_)
        else:
            return updateType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_WebAppAuthServerRecordField(self):
        return self.WebAppAuthServerRecordField
    def set_WebAppAuthServerRecordField(self, WebAppAuthServerRecordField):
        self.WebAppAuthServerRecordField = WebAppAuthServerRecordField
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def add_WebAppAuthServerRecordField(self, value):
        self.WebAppAuthServerRecordField.append(value)
    def insert_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField.insert(index, value)
    def replace_WebAppAuthServerRecordField_at(self, index, value):
        self.WebAppAuthServerRecordField[index] = value
    def hasContent_(self):
        if (
            self.WebAppAuthServerRecordField
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType5', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('updateType5')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='updateType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='updateType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='updateType5'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='updateType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for WebAppAuthServerRecordField_ in self.WebAppAuthServerRecordField:
            WebAppAuthServerRecordField_.export(outfile, level, namespaceprefix_, name_='WebAppAuthServerRecordField', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'WebAppAuthServerRecordField':
            obj_ = WebAppAuthServerRecordField.factory(parent_object_=self)
            obj_.build(child_)
            self.WebAppAuthServerRecordField.append(obj_)
            obj_.original_tagname_ = 'WebAppAuthServerRecordField'
# end class updateType5


class listType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType7)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType7.subclass:
            return listType7.subclass(*args_, **kwargs_)
        else:
            return listType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType7', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType7')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType7', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType7'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType7', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class listType7


class setType8(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType8)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType8.subclass:
            return setType8.subclass(*args_, **kwargs_)
        else:
            return setType8(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType8', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType8')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType8')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType8', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType8'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType8', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class setType8


class addType9(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType9)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType9.subclass:
            return addType9.subclass(*args_, **kwargs_)
        else:
            return addType9(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType9', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType9')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType9')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType9', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType9'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType9', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class addType9


class removeType10(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Tag is None:
            self.Tag = []
        else:
            self.Tag = Tag
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, removeType10)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if removeType10.subclass:
            return removeType10.subclass(*args_, **kwargs_)
        else:
            return removeType10(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tag(self):
        return self.Tag
    def set_Tag(self, Tag):
        self.Tag = Tag
    def add_Tag(self, value):
        self.Tag.append(value)
    def add_Tag(self, value):
        self.Tag.append(value)
    def insert_Tag_at(self, index, value):
        self.Tag.insert(index, value)
    def replace_Tag_at(self, index, value):
        self.Tag[index] = value
    def hasContent_(self):
        if (
            self.Tag
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType10', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('removeType10')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='removeType10')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='removeType10', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='removeType10'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='removeType10', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Tag_ in self.Tag:
            Tag_.export(outfile, level, namespaceprefix_, name_='Tag', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tag':
            obj_ = Tag.factory(parent_object_=self)
            obj_.build(child_)
            self.Tag.append(obj_)
            obj_.original_tagname_ = 'Tag'
# end class removeType10


class listType11(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, listType11)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if listType11.subclass:
            return listType11.subclass(*args_, **kwargs_)
        else:
            return listType11(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType11', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('listType11')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='listType11')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='listType11', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='listType11'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='listType11', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class listType11


class setType12(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, setType12)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if setType12.subclass:
            return setType12.subclass(*args_, **kwargs_)
        else:
            return setType12(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType12', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('setType12')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='setType12')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='setType12', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='setType12'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='setType12', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class setType12


class addType13(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Comment=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Comment is None:
            self.Comment = []
        else:
            self.Comment = Comment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, addType13)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if addType13.subclass:
            return addType13.subclass(*args_, **kwargs_)
        else:
            return addType13(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Comment(self):
        return self.Comment
    def set_Comment(self, Comment):
        self.Comment = Comment
    def add_Comment(self, value):
        self.Comment.append(value)
    def add_Comment(self, value):
        self.Comment.append(value)
    def insert_Comment_at(self, index, value):
        self.Comment.insert(index, value)
    def replace_Comment_at(self, index, value):
        self.Comment[index] = value
    def hasContent_(self):
        if (
            self.Comment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType13', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('addType13')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='addType13')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='addType13', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='addType13'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='addType13', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Comment_ in self.Comment:
            Comment_.export(outfile, level, namespaceprefix_, name_='Comment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Comment':
            obj_ = Comment.factory(parent_object_=self)
            obj_.build(child_)
            self.Comment.append(obj_)
            obj_.original_tagname_ = 'Comment'
# end class addType13


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'ServiceRequest'
        rootClass = ServiceRequest
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from webappauthrecord import *\n\n')
        sys.stdout.write('import webappauthrecord as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "Cdata",
    "Certificate",
    "Comment",
    "CommentList",
    "Criteria",
    "ResponseErrorObject",
    "SeleniumScript",
    "ServiceRequest",
    "ServiceRequestData",
    "ServiceRequestFilters",
    "ServiceRequestPreferences",
    "ServiceResponse",
    "ServiceResponseData",
    "Tag",
    "TagList",
    "User",
    "WebAppAuthFormRecord",
    "WebAppAuthFormRecordField",
    "WebAppAuthFormRecordFieldList",
    "WebAppAuthRecord",
    "WebAppAuthServerRecord",
    "WebAppAuthServerRecordField",
    "WebAppAuthServerRecordFieldList",
    "addType",
    "addType13",
    "addType3",
    "addType9",
    "listType",
    "listType1",
    "listType11",
    "listType7",
    "removeType",
    "removeType10",
    "removeType4",
    "setType",
    "setType12",
    "setType2",
    "setType8",
    "updateType",
    "updateType5"
]
