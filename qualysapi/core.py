from io import StringIO

from lxml import objectify, etree

from qualysapi import api_objects
from qualysapi.gen import webapp

class UnexpectedResponseCodeException(Exception):
    pass


class QualysModule(object):
    """
    Connector handles HTTP issues, and rate limiting issues.
    QualysModule handles pagination and error codes
    modules generated by generateDS handle parsing results sets
    subclass of QualysModule handle logic of returning the adequate objects

    Dev modifiable Object classes are in webappsubs.py
    """
    def __init__(self, connector):
        self.connector = connector
        self.__parser = objectify.makeparser(remove_blank_text=True)
        lookup = api_objects.make_custom_class_lookup()
        self.__parser.set_element_class_lookup(lookup)

    @property
    def _parsing_module(self):
        return self._get_parsing_module()

    def _get_parsing_module(self):
        # generateDS class
        raise NotImplementedError

    def _make_request_filter_data(self, criterias: list):
        # use objectify
        request_data = objectify.Element("ServiceRequest")
        request_data.filters = objectify.Element("ServiceRequestFilters")
        for c in criterias:
            request_data.filters.append(c)
        objectify.deannotate(request_data)
        etree.cleanup_namespaces(request_data)
        obj_xml = etree.tostring(request_data,
                                 pretty_print=True,
                                 xml_declaration=True)
        return obj_xml

    def _make_pagination_offset_queries(self, response, endpoint, http_method):
        filters = kwargs.get('filters')
        data = kwargs.get('data')
        total_limit = kwargs.get('preferences') or 100
        running_count = response.count + 1
        # preferences = kwargs.get('preferences')
        #
        has_more = True
        while has_more and running_count < total_limit:
            preferences = self._parsing_module.ServiceRequestPreferences(startFromOffset=running_count, limitResults=total_limit-running_count)
            request = self._parsing_module.ServiceRequest(filters=filters, preferences=preferences, data=data)
            response2 = self._parsing_module.parseString(self.connector.request(endpoint, http_method=http_method, data=request), silence=True)
            response2 = self._handle_response_code(response2)
            yield response2.data
            has_more = response2.hasMoreRecords
            running_count += response2.count
            total_limit += response2.count
        #
        pass

    def _handle_pagination(self, response, endpoint, http_method):
        if not response.hasMoreRecords:
            return response
        combined_results = [response.data]
        for data in self._make_pagination_offset_queries(response, endpoint, http_method):
            combined_results.append(data)
        return combined_results # FIXME

    def _handle_response_code(self, response):
        # check return status
        if response.responseCode.text != 'SUCCESS':
            raise UnexpectedResponseCodeException(response.responseCode, response.responseErrorDetails.errorMessage)
        return response

    def _validate_method(self):
        pass

    def request(self, api, **kwargs):
        """

        :param api:
        :param args: provide named arg
        :param kwargs:
        :return:
        """
        endpoint, methods = api
        http_method = kwargs.get('http_method') or methods[0]
        data = kwargs.get('data')
        full_endpoint = endpoint.format(**kwargs)
        response = self.connector.request(full_endpoint, http_method=http_method, data=data)
        # response = self._parsing_module.parseString(response, silence=True)
        response = objectify.fromstring(response.encode('utf-8'), self.__parser)
        response = self._handle_response_code(response)
        response = self._handle_pagination(response, full_endpoint, http_method)
        return response






class Operation(object):
    """
    Enum representing all API supported operators
    """
    """
    Integer EQUALS, NOT EQUALS, GREATER, LESSER, IN
    Text CONTAINS, EQUALS, NOT EQUALS
    Date EQUALS, NOT EQUALS, GREATER, LESSER
    Keyword EQUALS, NOT EQUALS, IN
    Boolean (true/false) EQUALS, NOT EQUALS
    """


class RequestFilter(object):
    """
    TODO
    """
    def __init__(self):
        """
        QueryFilter is basically a representation of query params to be sent
        as dictionary
        """
        self.filters = {}
        for key in list(self.QUERY_ARGS.keys()):
            try:
                self.QUERY_ARGS[key].index('in')
            except ValueError:
                continue
            self.QUERY_ARGS[key + ('es' if key.endswith('s') else 's')] = ['eq']

    def apply(self, key, val, op=''):
        if key not in self.QUERY_ARGS:
            raise InvalidFilterException("Filter field not allowed for this endpoint")
        if op and op not in self.QUERY_ARGS[key]:
            raise InvalidFilterException("Operator not allowed")
        if not op:
            allowed_ops = self.QUERY_ARGS[key]
            if Op.EQ not in allowed_ops and len(allowed_ops) > 1:
                raise InvalidOperatorException(
                    "More than one allowed operator, unable to choose default, please provide operator")
            op = allowed_ops[0]

        self.filters[self.transform(key, op)] = val
        return self

    def validate(self, filter_obj):
        raise NotImplementedError

    @classmethod
    def transform(cls, key, op):
        """
        transform a key and a op to a SentinelOne api string, example:
        transform('createdAt', 'gt') -> createdAt__gt
        transform('resolved', 'eq') -> resolved
        """
        if op == Op.EQ:
            return key
        return '{}__{}'.format(key, op)

    @classmethod
    def get_query_params(cls, query_filter, filter_args):
        """
        :param query_filter: object representing the filters
        :type query_filter: QueryFilter
        :param filter_args: Filters in form of key value
        :type filter_args: **dict
        :return: dictionary with key value in the server's language
        """
        ret = {}

        if query_filter and filter_args:
            raise InvalidFilterException("Please provide query filter object or kwargs, but not both")

        if not query_filter and not filter_args:
            return ret

        if query_filter:
            return query_filter.filters

        if filter_args:
            filter = cls()
            for arg in filter_args:
                operator_obj = SplittedHelper(arg.split('__'))
                if hasattr(operator_obj, 'op'):
                    filter.apply(operator_obj.field, filter_args[arg], operator_obj.op)
                else:
                    filter.apply(operator_obj.field, filter_args[arg])
            return filter.filters



def pull_xsd(server='qualysapi.qualys.com'):
    import requests
    import os
    todos = [('webapp.xsd', f'https://{server}/qps/xsd/3.0/was/webapp.xsd'),
             ('webappauthrecord.xsd', f'https://{server}/qps/xsd/3.0/was/webappauthrecord.xsd'),
             ('scan.xsd', f'https://{server}/qps/xsd/3.0/was/scan.xsd'),
             ('schedule.xsd', f'https://{server}/qps/xsd/3.0/was/schedule.xsd'),
             ('report.xsd', f'https://{server}/qps/xsd/3.0/was/report.xsd'),
             ('optionprofile.xsd', f'https://{server}/qps/xsd/3.0/was/optionprofile.xsd'),
             ('finding.xsd', f'https://{server}/qps/xsd/3.0/was/finding.xsd'),
             ]
    def dl_and_save(filename, url):
        response = requests.get(url, stream=True)
        # Throw an error for bad status codes
        response.raise_for_status()
        with open(filename, 'wb') as handle:
            for block in response.iter_content(1024):
                handle.write(block)
        return filename
    for fname, url in todos:
        dl_and_save(os.path.sep.join(['qualysapi', 'gen', fname]), url)
        print(f"Downloaded {fname}")
    return


if __name__ == '__main__':
    pull_xsd()
